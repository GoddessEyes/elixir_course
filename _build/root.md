---
title: Elixir Junior. Учебный курс.
author: Юрий Жлоба
rights: Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License
lang: ru-RU
date: 2022-09-10
---

# Урок №1. Первое знакомство с Elixir.

## Решаем задачу FizzBuzz

Начнем знакомство с Эликсир на примере решения задачи [FizzBuzz](https://ru.wikipedia.org/wiki/Fizz_buzz):

_Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»._

Это простая задача позволит познакомиться со многими важными элементами языка:
- модули и функции;
- генерация списка с помощью `Range`;
- итерация по списку с помощью `Enum.each`;
- условые переходы с помощью `cond do`;
- охранные выражения (guards);

- вывод на консоль;
- оператор pipe;
- и юнит-тесты.

Пока что мы не будем углубляться в суть этих элементов, а посмотрим на них беглым взглядом.


### Шаг 1. Простая реализация задачи.

~~~elixir
defmodule FizzBuzz01 do

  def main() do
    Enum.each(1..100, &fizzbuzz/1)
  end


  def fizzbuzz(n) do
    cond do
      rem(n, 3) == 0 and rem(n, 5) == 0 -> IO.puts("FizzBuzz")
      rem(n, 3) == 0 -> IO.puts("Fizz")
      rem(n, 5) == 0 -> IO.puts("Buzz")
      true -> IO.puts(n)
    end
  end

end
~~~

Создаем модуль `FizzBuzz01` и в нем две функции `main` и `fizzbuzz`. 

В функции `main` мы генерируем последовательность от 1 до 100. Конструкция `1..100` -- это генератор последовательности, он называется **Range**. Затем с помощью `Enum.each` мы применяем функцию `fizzbuzz` к каждому элементу.

`fizzbuzz` использует конструкцию `cond do` и охранные выражения (guards) чтобы проверить условия делимости на 3 и на 5. Первое охранное выражение выполняется, если `n` делится на 3 и на 5. Второе охранное выражение выполняется, если `n` делится на 3. Третье, если `n` делится на 5. И последнее, четвертое охранное выражение выполняется всегда, так как оно представлено просто значением `true`. 

Функция `rem`, как не трудно догадаться, возвращает остаток от деления.

`cond do` проверяет выражения по очереди, и выполняет только одну ветку кода, соответствующую первому истинному выражению. `IO.puts` выводит нужное значение на стандартный вывод.

### Шаг 2. Отделяем вывод на консоль от логики.

Функция `fizzbuzz` выводит сообщения на консоль, что не очень хорошо с точки зрения функционального программирования. Разделим нашу задачу на две:

1. Преобразовать список чисел `1..100` в другой список, состоящий из чисел и строк "Fizz", "Buzz", "FizzBuzz".

2. Вывести результат на консоль.

~~~elixir
defmodule FizzBuzz02 do

  def main() do
    1..100
    |> Enum.map(&fizzbuzz/1)
    |> Enum.join(" ")
    |> IO.puts()
  end


  @spec fizzbuzz(integer) :: String.t
  def fizzbuzz(n) do
    divisible_by_3 = rem(n, 3) == 0
    divisible_by_5 = rem(n, 5) == 0
    cond do
      divisible_by_3 and divisible_by_5 -> "FizzBuzz"
      divisible_by_3 -> "Fizz"
      divisible_by_5 -> "Buzz"
      true -> to_string(n)
    end
  end

end
~~~

Функция `fizzbuzz` теперь стала **чистой функцией**. Её результат зависит только от входного значения, и она не делает ничего, кроме вычисления результата. Чистые функции легко понять и протестировать. А так же их легко компоновать друг с другом.

## Интерактивная консоль (iex)

Посмотрим на интерактивную консоль **iex** -- второй по важности, после редактора, инструмент разработчика.

Многие языки программирования имеют REPL консоль. Она дает возможность работать интеративно: запускать небольшие куски кода и сразу же видеть результ. REPL означает Read, Eval, Print, Loop. То есть, консоль читает код, выполняет его, выводит результат, и опять читает код.

Мы уже начали активно пользоваться консолью когда реализовывали FizzBuzz. Теперь познакомимся с ней поближе:

~~~
~/p/elixir_course_junior/lib/lesson_01 $ iex
Erlang/OTP 23 [erts-11.1] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

Interactive Elixir (1.13.4) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)>
~~~

Мы видим версию Эрланг: `Erlang/OTP 23`, версию Erlang Runtime System: `erts-11.1` и версию Эликсир: `Elixir (1.13.4)`.


### Компиляция

iex-консоль имеет много встроенных функций. Самые популярные из них имеют однобуквенные называния. 

Мы уже пользовались функцией `c`, которая компилирует и загружает код:

~~~
iex(1)> c "lib/fizz_buzz_02.exs"
[FizzBuzz02]
B>
~~~

Другая популярная функция -- это `h`, которая показывает справку по функциям и модулям Эликсир. Посмотрим справку по функции `c`:

~~~
iex(2)> h c
                        def c(files, path \\ :in_memory)                         

Compiles the given files.
...
~~~

Мы видим, что функция `c` компилирует один или несколько файлов, загружает их в память консоли, или сохраняет сгенерированный байт-код по указаному пути. 

Если мы вносим изменения в код, то с помощью функции `r` мы можем перекомпилировать модуль заново и загрузить свежую версию.

~~~
iex(3)> r FizzBuzz02
warning: redefining module FizzBuzz02 (current version defined in memory)
  lib/fizz_buzz_02.exs:1

{:reloaded, [FizzBuzz02]}
~~~

Таким образом удобно вести интерактивную разработку -- писать код и тут же проверять в консоли, как он работает. 

Для больших проектов неудобно перекомпилировать по-отдельности каждый измененный модуль. Поэтому в консоли есть функция `recompile`, которая пересобирает весь проект. Однако, для этого нужно иметь полноценный проект с правильной структурой кода, а не просто несколько модулей.


### Автодополнение

Для кода, который скомпилирован и загружен в консоль, работает автодополнение модулей и функций:

~~~
iex(4)> Fizz.<tab>
iex(5)> FizzBuzz02.<tab>
iex(6)> FizzBuzz02.m<tab>
iex(7)> FizzBuzz02.main
~~~

# Урок №2. История, мотивация.

## Немного истории.

Немного истории.

## Важные свойства BEAM.

Важные свойства BEAM.

# Урок №3. Типы данных и операции над ними.

## Типы данных.

Типы данных.

## Int.

Int.
