# Абстракции над процессами: Task, Agent, GenServer.

**spawn**, **send** и **receive** -- это низкий уровень работы с процессами, который в реальных проектах практически не используется. Это кирпичики, из которых построены высокоуровневые средства, более удобные и надежные. 

В этом уроке мы рассмотрим три таких средства: **Task**, **Agent** и **GenServer**.

Task и Agent -- относительно простые, но при этом мощные инструменты для задач многопоточности. 

GenServer -- краеугольный камень OTP-фреймворка, важнейшая основа любых проектов на Эликсире и Эрланге. Поэтому мы подробно остановимся на нем, изучим изнутри и снаружи.

Процессы бывают короткоживущие и долгоживущие. Короткоживущие процессы запускаются, чтобы сделать одну конкретную задачу и получить некий результат. После этого процесс больше не нужен. Они не обмениваются сообщениями, за исключением возврата конечного результата. В этом случае удобно использовать Task.

Долгоживущие процессы запускаются на старте системы, живут вместе с ней и завершаются вместе с ней. Они выполняют много задач, одинаковых или разных, и активно обмениваются сообщениями с другими процессами. Для них используют Agent или GenServer.


# Task

[Task](https://hexdocs.pm/elixir/1.12/Task.html) обычно используется, чтобы выполнить некую задачу асинхронно, не блокируя основную задачу.

Для примера, посчитаем количество слов в файле:

```
file = "./10_01_task.md"

my_task = fn () ->
  {:ok, content} = File.read(file)
  String.split(content) |> length()
end

task_id = Task.async(my_task)
result = Task.await(task_id)
```

Те, кто имеет опыт с асинхронным кодов в любом языке, увидят здесь знакомый подход. Вызов `Task.async` не блокирует основной поток выполнения, а возвращает некий индентификатор, по которому можно будет получить результат позже. 

Вызов `Task.await` запрашивает результат. Если вычисление уже завершено, то результат вернется сразу. Иначе основной поток блокируется и ждет завершения вычисления. 

По умолчанию поток блокируется на 5 секунд, и если за это время результат не приходит, то генерируется исключение:

```
sleep_6_sec = fn () ->
  Process.sleep(6000)
  :ok
end

task_id = Task.async(sleep_6_sec)
result = Task.await(task_id)
```

Можно явно указать время ожидания:

```
task_id = Task.async(sleep_6_sec)
result = Task.await(task_id, 7000)
```

Если процесс внутри Task завершается аварийно, то при запросе `Task.await` так же генерируется исключение:

```
crash = fn () ->
  exit(:normal)
end

task_id = Task.async(crash)
result = Task.await(task_id)
```


## MapReduce

Task хорошо подходит для реализации MapReduce. Идея тут простая -- сперва нужно запустить несколько Task, а затем запросить результат у каждого из них.

Для этого удобный АПИ [async_stream/3](https://hexdocs.pm/elixir/1.12/Task.html#async_stream/3)

async_stream(Enumerable.t(), (term() -> term()), keyword()) :: Enumerable.t()

Returns a stream that runs the given function fun concurrently on each element in enumerable.

Each enumerable element is passed as argument to the given function fun and processed by its own task. The tasks will be linked to the current process, similarly to async/1.

When streamed, each task will emit {:ok, value} upon successful completion or {:exit, reason} if the caller is trapping exits. 

Напомнить, как работает Stream. Придумать пример с Enum.take.

решение уже есть, показать


## Tasks and Supervision

анонсировать что это будет в следущем уроке

Besides async/1 and await/2, tasks can also be started as part of a supervision tree and dynamically spawned on remote nodes. 
