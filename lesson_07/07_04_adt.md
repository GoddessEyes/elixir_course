## Алгебраические типы данных

Теперь немного теории. В функциональном программировании есть понятие Алгебраических типов данных, ADT (Algebraic data type). 
Суть их в том, что для данных определены некоторые алгебраические операции.

Например, Event это название И время И место И участники И агенда. Это произведение (умножение, product) данных. Интуитивно может показаться, что это сумма. Но нет, интуиция нас здесь обманывает. 

Самое простое произведение -- это кортеж:
```
{:event, "Team Meeting", datetime, location, participants, agenda}
```

В языке OCaml тип кортежа так и обозначается -- через знак умножения:
```
String * Datetime * Participant list * Topic list
```

Struct -- это тоже произведение:
```
%Event.Event{
  title: "Team Meeting",
  datetime: ~U[2021-03-10 19:40:00.000000Z],
  location: location,
  participants: [helen, bob, kate, tihon],
  agenda: agenda
}
```

Теперь посмотрим на **%Event.Participant.species**. И **%Event.Participant.role**. 
В нашем примере встречаются два вида species -- это :human ИЛИ :cat. 
И встречаются три вида role -- это :project_manager ИЛИ :developer ИЛИ :cat.

Это перечисление (сумма, sum) данных. 

Во многих языках для этого есть тип Enum, который определяет конечное множество значений.
Например, в OCaml это было бы так:
```
data Species = Human | Cat
data Role = ProjectManager | Developer | Cat
```
И компилятор не позволит присвоить какие-либо другие значения, кроме перечисленных.

К сожалению, в Эликсир нет типа Enum на уровне компилятора. Но можно описать этот тип для dialyzer:
```
@type species :: :human | :cat
@type role :: :project_manager | :developer | :cat
```
(Зато в Elixir есть модуль Enum, что вносит некоторую путаницу. Название совсем неудачное, правильно было бы назвать этот модуль -- Collection).

Произведение и сумма (product & sum) позволяют описать любые объекты. Раньше мы говорили что кортеж и список позволяют моделировать любые объекты. ADT -- это другой уровень абстракции. Здесь список элементов и одиночный элемент рассматриваются как одно и то же. А кортежа мало, нужно еще перечисление.

Какая же от всего этого польза? Польза в том, что на этом строится система типов в тех функциональных языках, где есть статическая типизация. Эликсир прямо не относится к таким языкам, но благодаря dialyzer здесь тоже есть система типов, построенная на тех же принципах. 

В языках с полноценной реализацией ADT (это, например, OCaml, Haskell, Scala, F#), при применении pattern matching к типу Enum проверяется, что в шаблонах использованы все возможные значения:
```
case tihon.species do
  :human -> do_something
  :cat -> do_something_else
end

case tihon.role od
  :cat -> do_something
  :developer -> do_something_else
end
```
Первый пример скомпилировался бы нормально, а во втором примере компилятор выдал бы ошибку, что не использовано значение :project_manager. Компилятор не дал бы разработчику забыть про эту важную роль :)

Увы, dialyzer так не умеет.
