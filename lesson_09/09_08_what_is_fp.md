# Что такое функциональное программирование?

Мы формулировали ответ на этот вопрос в 7-м уроке. Но сейчас вернёмся к нему ещё раз.

На более высоком уровне идея ФП сводится к композиции функций.

Функция может принять простое значение, или значение обёрнутое в монаду. Функция может вернуть простое значение, или монаду. Все эти варианты нужно комбинировать между собой. И тут речь только про функции от одного аргумента. Если аргументов больше, то ситуация усложняется ещё больше.

В некоторых языках (Haskell, OCaml), благодаря каррированию любая функция может быть представлена как функция от одного аргумента. Но в Эликсир нет каррирования.

TODO объяснить каррирование.

В идеале любая функциональная программа сводится к линейной цепочке:

```
Fun1 Comp1 Fun2 Comp2 Fun3 Comp3 Fun4
```

И в этой цепочке обрабатываются все возможные выходы: позитивные результаты и ошибки, и все побочные эффекты. 

Популярных монад не так много: Result, Maybe, IO. 

TODO объяснить каждую из этих монад.

Ocaml и Rust обходятся небольшим количеством монад. А в Haskell их гораздо больше. Например, список и функцию тоже можно представить как монаду. Что, врочем, является в большей степени интеллектуальным упражнением, чем полезной на практике идеей.

Сама идея свести всю программу к цепочке функций тоже не очень практична. 

А может быть, мы к этому просто не привыкли. В 80-х годах победило императивное программирование просто потому, что оно гораздо эффективнее использовало имеющиеся ресурсы: CPU и память. И эти ресурсы тогда были в дефиците. Если бы тогда победило функциональное программирование, то мир программирования сегодня выглядел бы совершенно иначе :)
