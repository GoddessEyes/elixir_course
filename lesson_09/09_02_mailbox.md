# Почтовый ящик

У каждого процесса есть специальная область памяти -- почтовый ящик (mailbox), куда копируются адресованные ему сообщения. Там сообщения накапливаются в очереди, в порядке их появления.

Чтобы прочитать сообщения в почтовом ящике, нужно использовать конструкцию `receive`. Она аналогична конструкции `case`, тоже состоит из шаблонов и охранных выражений.

```
iex(1)> c "09_02_mailbox.exs"
[Lesson_09.Task_02_Mailbox]
iex(2)> alias Lesson_09.Task_02_Mailbox, as: T
Lesson_09.Task_02_Mailbox

iex(3)> send(self(), {:tag1, "Hello"})
{:tag1, "Hello"}
iex(4)> T.check_mailbox()
got msg with tag1: "Hello"
:ok

iex(5)> send(self(), {:tag2, "Hi"})
{:tag2, "Hi"}
iex(6)> send(self(), :hello)
:hello
iex(7)> T.check_mailbox()
got msg with tag2: "Hi"
:ok
iex(8)> T.check_mailbox()
got unknown msg :hello
:ok
```



## receive .. after

Если в момент вызова receive почтовый ящик пуст, то процесс блокируется и ждет сообщений. Часто нужно ограничить время ожидания. Для этого используется `receive .. after`.

```
iex(3)> T.check_mailbox(1000)
no messages after 1000 ms
:ok
iex(4)> send(self(), :hello)
:hello
iex(5)> T.check_mailbox(1000)
got msg :hello
:ok
```


## receive действует избирательно

receive забирает из почтового ящика только одно сообщение, первое, подходящее по шаблону. Остальные сообщения остаются в очереди и ждут.

```
iex(8)> send(self(), 41)
41
iex(9)> send(self(), 42)
42
iex(10)> send(self(), 43)
43
iex(11)> T.check_for_42()
got 42
:ok
iex(12)> flush()
41
43
:ok
```

Если подходящего сообщения нет, то все сообщения остаются в очереди.

```
iex(13)> send(self(), 31)
31
iex(14)> send(self(), 32)
32
iex(15)> send(self(), 33)
33
iex(16)> T.check_for_42()
:ok
iex(17)> flush()
31
32
33
```


## Переполнение почтового ящика

Размер почтового ящика не ограничен. Если процесс забирает не все сообщения, или забирает их медленнее, чем они поступают, то очередь растет.

Чем больше очередь, тем медленнее работает receive, потому что ему нужно проверить все сообщения в очереди по своим шаблонам. 

Это одна из частых проблем в BEAM. Из-за растущих очередей система сперва замедляется, затем потребляет всю доступную память и аварийно завершается. Поэтому разработчики всегда следят за тем, чтобы процессы успевали потреблять все входящие сообщения. 

Хорошая практика -- делать в receive последний шаблон такой, чтобы он совпадал с любым сообщением. И в этом случае писать в лог предупреждение о том, что процесс получил сообщение, которое он не умеет обрабатывать. Это называется *catch all* шаблон.

```
iex(19)> send(self(), :something_not_expected)
:something_not_expected
iex(20)> T.check_mailbox()
got unknown msg :something_not_expected
:ok
```

Это не гарантирует защиту от переполнения, но уменьшает вероятность проблем. 

Это является хорошей практикой еще и потому, что если процесс получает неожиданные сообщения, то скорее всего где-то в коде есть баг -- сообщения отправляются не туда, куда должны отправляться. catch all шаблон позволяет заметить это. 


TODO stopped here

## Регистрация процессов

Pid -- штука хорошая, но не всегда удобная. Если мы хотим посылать сообщения в процесс из нескольких других процессов, нам придется как-то передать всем им Pid получателя.

Но есть альтернатива -- процессу можно дать некое имя, глобальное на уровне всей ноды, и потом обращаться к нему по этому имени.

``` TODO elixir
register(Name, Pid)
```

Вызов register сгенерирует исключение, если имя уже связано с другим процессом.

Регистрацию процесса можно отменить:

``` TODO elixir
unregister(Name)
```

Можно узнать все имена зарегистрированных процессов, какие есть в ноде:

``` TODO elixir
registered()
```

И можно узнать Pid процесса по имени:

``` TODO elixir
whereis(Name)
```

Пробуем: 

``` TODO elixir
1> registered().
[erl_prim_loader,error_logger,kernel_safe_sup,init,user,rex,
 inet_db,kernel_sup,code_server,standard_error_sup,
 global_name_server,application_controller,file_server_2,
 user_drv,standard_error,global_group]
2> register(erl_console, self()).
true
3> registered().
[erl_prim_loader,error_logger,kernel_safe_sup,init,user,rex,
 inet_db,kernel_sup,code_server,standard_error_sup,
 global_name_server,erl_console,application_controller,
 file_server_2,user_drv,standard_error,global_group]
4> whereis(erl_console).
<0.33.0>
5> self().
<0.33.0>
6> unregister(erl_console).
true
```


## Выводы

Легкие процессы, обмен сообщениями, отсутсвие разделяемой памяти дают хорошую базу для:
- масштабируемости;
- распределенности;
- устойчивости к ошибкам.

Поскольку процессы -- дешевый ресурс, их можно создавать в количестве, адекватном нагрузке на систему, и менять вместе с изменением нагрузки.

Если мы умеем передавать сообщения от одного процессы другому в рамках одной ноды, то не сложно это делать и между двумя нодами. Нужен только транспорт поверх TCP, и в виртуальной машине  этот транспорт есть.

Поскольку процессы изолированы друг от друга, то падение одного процесса не влияет на работу других процессов.  Впрочем, устойчивость к ошибкам не появляется сама по себе, программисту еще нужно постараться, чтобы этого добиться :)
