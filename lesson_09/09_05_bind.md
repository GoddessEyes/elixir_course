# Вариант 4. Монада Result и оператор bind.

## Result

Исключения дали нам возможность сосредоточиться на happy path и не мучиться с шаблонной обработкой ошибок. В функциональном программировании есть другие инструменты с таким же эффектом.

В нашем примере есть несколько функций, которые возвращают результат вида `{:ok, result} | {:error, reason}`. Во многих функциональных языках для такой контрукции есть специальный тип данных:
- Haskell `Result e t`
- OCaml `('a, 't) result`
- Rust `Result<T, E>`
- Scala `Either[E, T]`

Этот тип данных означает, что результатом вызова функции могут быть два варианта: либо успешный результат, либо ошибка. То есть, возвращаемое значение отдается не напрямую, а завернутое в некую оболочку, контекст. Такое значение называется **монада**. Монады бывают разные, и Result -- одна из них. 

Если одна функция возвращает монаду Result, а другая принимает значение в чистом виде, то чтобы соединить эти две функции, нужно извлечь значение из монады. Это мы уже делали во 2-м варианте решения:

```
case f1(arg) do
  {:ok, data} -> f2(data)
  {:error, reason} -> {:error, reason}
end
```

Этот case мы явно писали каждый раз, когда соединяли функции. Такого рода соединение (композиция) функций -- очень частый паттерн в функциональном программировании. И в некоторых языках для него есть обобщенное решение. 


## bind

На Эликсир это можно реализовать так: 

```
def bind(f1, f2) do
  fn(args) ->
    case f1.(args) do
      {:ok, res} -> f2.(res)
      {:error, reason} -> {:error, reason}
    end
  end
end
```

И использовать так:

```
def main() do
  f = bind(&V.validate_incoming_data/1, &V.validate_cat/1)
  f.(BookShop.test_data)
end

iex(9)> FP.main
{:ok, {:cat, ...}}}
iex(10)> FP.main
{:error, :cat_not_found}
iex(11)> FP.main
{:error, :cat_not_found}
iex(12)> FP.main
{:error, :invalid_incoming_data}
```

Мы реализовали функцию **bind**, которая связывает две любые функции, где первая возвращает монаду Result. 

Если нужно связать несколько функций в цепочку, то это будет выглядеть так:

```
bind(bind(bind(f1, f2), f3), f4)
```

В Haskell и других языках есть аналогичный оператор:

```
f1 >>= f2 >>= f3 >>= f4
```

Как видим, с оператором это гораздо удобнее и писать, и читать.

Но попробуем применить bind к нашей задаче: bookshop/lib/solution_4.ex

Решение получилось не очень удачным. Во-первых, цепочка bind плохо читается. Но хуже другое -- функции, которые мы соединяем, не совпадают по входу и выходу. Поэтому пришлось обернуть их в другие функции, и пробрасывать через обертки некий общий state в виде map. 

В итоге получилось немного короче, чем 2-й вариант, но принципиально не лучше. И мы точно ничего не выйграли в сравнении с 3-м вариантом. И на этом примере пока что не получится кого-то убедить отказаться от исключений :)


## sequence

В этом решении есть еще один интересный нюанс. Функция `BookShop.get_book/2` работает с одной книгой, а у нас есть список книг. И когда мы с помощью `Enum.map/2` прогоняем наш список, то на выходе получаем `[{:ok, book1}, {:ok, book2}, {:ok, book}]`, или же `[{:ok, book1}, {:error, _}, {:ok, book}]`

А нам, чтобы двигаться по цепочке дальше, нужно `{:ok, [book1, book2, book3]}`, или первая ошибка в списке.

Это типовая задача в функциональном программировании -- превратить список монад в монаду над списком. В Haskell для этого есть стандартная функция **sequence**. В Эликсир такой функции нет, но её не сложно реализовать:

```
def sequence([]), do: {:ok, []}
def sequence([{:error, reason} | _]), do: {:error, reason} 
def sequence([{:ok, val} | tail]) do
  case sequence(tail) do
    {:ok, list} -> {:ok, [val | list]}
    {:error, error} -> {:error, error}
  end
end
```
