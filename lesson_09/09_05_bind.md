# Вариант 4. Монада Result и оператор bind.

## Result

Исключения дали нам возможность сосредоточиться на happy path и не мучиться с шаблонной обработкой ошибок. В функциональном программировании есть другие инструменты с таким же эффектом.

В нашем примере есть несколько функций, которые возвращают результат вида `{:ok, result} | {:error, reason}`. Во многих функциональных языках для такой контрукции есть специальный тип данных:
- Haskell `Result e t`
- OCaml `('a, 't) result`
- Rust `Result<T, E>`
- Scala `Either[E, T]`

Этот тип данных означает, что результатом вызова функции могут быть два варианта: либо успешный результат, либо ошибка. То есть, возвращаемое значение отдается не напрямую, а завернутое в некую оболочку, контекст. Такое значение называется **монада**. Монады бывают разные, и Result -- одна из них. 

Если одна функция возвращает монаду Result, а другая принимает значение в чистом виде, то чтобы соединить эти две функции, нужно извлечь значение из монады. Это мы уже делали во 2-м варианте решения:

```
case f1(arg) do
  {:ok, data} -> f2(data)
  {:error, reason} -> {:error, reason}
end
```

Этот case мы явно писали каждый раз, когда соединяли функции. Такого рода соединение (композиция) функций -- очень частый паттерн в функциональном программировании. И в некоторых языках для него есть обобщенное решение. 


## bind

На Эликсир это можно реализовать так: 

```
def bind(f1, f2) do
  fn(args) ->
    case f1.(args) do
      {:ok, res} -> f2.(res)
      {:error, reason} -> {:error, reason}
    end
  end
end
```

Мы реализовали функцию **bind**, которая связывает две любые функции, где первая возвращает монаду Result. 

Если нужно связать несколько функций в цепочку, то это будет выглядеть так:

```
bind(bind(bind(f1, f2), f3), f4)
```

В Haskell и других языках есть оператор bind:

```
f1 >>= f2 >>= f3 >>= f4
```

Оператор pipe поможет нам сделать похожий вариант в Эликсир:

```
bind(f1, f2) |> bind(f3) |> bind(f4)
```

Но попробуем применить bind к нашей задаче: bookshop/lib/solution_4.ex

Функции, которые мы соединяем, не совпадают по входу и выходу. Поэтому пришлось обернуть их в другие функции, и пробрасывать через обертки некий общий state в виде map. 

В итоге получилось немного короче, чем 2-й вариант, но принципиально не лучше. И мы точно ничего не выйграли в сравнении с 3-м вариантом. И на этом примере пока что не получится кого-то убедить отказаться от исключений :)


## sequence

В этом решении есть еще один интересный нюанс. Функция `BookShop.get_book/2` работает с одной книгой, а у нас есть список книг. И когда мы с помощью `Enum.map/2` прогоняем наш список, то на выходе получаем `[{:ok, book1}, {:ok, book2}, {:ok, book}]`, или же `[{:ok, book1}, {:error, _}, {:ok, book}]`

А нам, чтобы двигаться по цепочке дальше, нужно `{:ok, [book1, book2, book3]}`, или первая ошибка в списке.

Это типовая задача в функциональном программировании -- превратить список монад в монаду над списком. В Haskell для этого есть стандартная функция **sequence**. В Эликсир такой функции нет, но её не сложно реализовать:

```
def sequence(list) do
  Enum.reduce(
    list,
    {:ok, []},
    fn
      (_, {:error, _} = acc) -> acc
      ({:ok, v}, {:ok, acc}) -> {:ok, [v | acc]}
      ({:error, _} = e, _) -> e
    end
  )
end
```
