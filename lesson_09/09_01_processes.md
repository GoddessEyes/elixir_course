# Работа с процессами на низком уровне

Эффективная поддержка многопоточности -- одна из главных фишек виртуальной машины BEAM. И она же является базой для других её своств: масштабируемости, распределенности, устойчивости к ошибкам.


## Процессы и потоки

Прежде, чем мы начнем погружаться в эту тему, нужно уточнить терминологию. 

Процесс (process) -- сущность на уровне операционной системы, с которой связаны ряд ресурсов:
адресное пространство, файловые дескрипторы (в тч стандартный ввод-вывод), сокеты, пользовательские права и др.


Поток (thread) -- в рамках одного процесса могут существовать несколько потоков, которые разделяют между собой общие ресурсы.
Поток выполнения (тред; от англ. thread — нить) — наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы
Реализация потоков выполнения и процессов в разных операционных системах отличается друг от друга, но в большинстве случаев поток выполнения находится внутри процесса.
Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют инструкции процесса (его код) и его контекст (значения переменных, которые они имеют в любой момент времени).
Некоторые реализации ядра называют потоком ядра, другие же — легковесным процессом (англ. light-weight process, LWP), представляющим собой особый тип потока выполнения ядра, который совместно использует одни и те же состояния и данные.

Потоки выполнения отличаются от традиционных процессов многозадачной операционной системы тем, что:
процессы, как правило, независимы, тогда как потоки выполнения существуют как составные элементы процессов
процессы несут значительно больше информации о состоянии, тогда как несколько потоков выполнения внутри процесса совместно используют информацию о состоянии, а также память и другие вычислительные ресурсы
процессы имеют отдельные адресные пространства, тогда как потоки выполнения совместно используют их адресное пространство
процессы взаимодействуют только через предоставляемые системой механизмы связей между процессами
переключение контекста между потоками выполнения в одном процессе, как правило, быстрее, чем переключение контекста между процессами.
Потоки выполнения одного и того же процесса совместно используют одно и то же адресное пространство. Это позволяет одновременно выполняющимся кодам быть плотно связанными и удобно обмениваться данными без накладных расходов и сложности межпроцессного взаимодействия. 


Нить выполнения (grean thread) -- поток, реализованный на уровне виртуальной машины, а не ОС.
Потоки выполнения иногда реализуются в пользовательском пространстве библиотек, в этом случае они называются пользовательскими потоками выполнения. Ядро не знает о них, так что они управляются и планируются в пользовательском пространстве. 
Пользовательские потоки выполнения, реализованные с помощью виртуальных машин, называют также «зелёными потоками выполнения».
Реализация пользовательских потоков выполнения и файберов, как правило, производится полностью в пользовательском пространстве. В результате переключение контекста между пользовательскими потоками выполнения и файберами в одном и том же процессе очень эффективно, поскольку вообще не требует никакого взаимодействия с ядром.

Если пользовательский поток выполнения или файбер выполняет системный вызов, другие потоки выполнения и файберы процесса не могут работать до завершения этой обработки. Типичный пример такой проблемы связан с выполнением операций ввода-вывода. Большинство программ рассчитаны на синхронное выполнение ввода-вывода.
При инициации ввода-вывода делается системный вызов, и он не возвращается до его завершения. В промежутке весь процесс блокируется ядром и не может исполняться, лишая возможности работы другие пользовательские потоки и файберы этого процесса.

В программировании зелёные потоки (англ. green threads) — это потоки выполнения, управление которыми вместо операционной системы производит виртуальная машина (ВМ). Green threads эмулируют многопоточную среду, не полагаясь на возможности ОС по реализации легковесных потоков. Управление ими происходит в пользовательском пространстве, а не пространстве ядра, что позволяет им работать в условиях отсутствия поддержки встроенных потоков.[1]

Но когда мы говорим про BEAM, то у нас есть только одна сущность. В англоязычной документации и литературе используют термин **process**. В русскоязычной могут встречаться и "процесс" и "поток", но имеется в виду одно и то же. 


## Легковесные процессы BEAM

С точки зрения ОС это потоки в пользовательском пространстве, внутри вирутальной машины. Ими управляет не ОС, а сама виртуальная машина. То есть, это зеленые потоки. Однако они существенно отличаются от потоков, описаных выше.

BEAM имеет собственную реализацию многопоточности поверх процессов операционной системы. На одном системном процессе могут работать сотни и тысячи процессов BEAM. Виртуальная машина управляет ими независимо от операционной системы.

Processes are isolated from each other, run concurrent to one another and communicate via message passing.

Isolated:
- don't share memory
- don't block each other from running
- one processes crash don't crash other processes (except we want it happens)


Особенность процессов BEAM в том, что они легковесные. Это значит, что они:
- быстро стартуют и завершаются;
- быстро переключаются;
- потребляют мало памяти.

Новый процесс создается и стартует за 3-5 микросекунд. На старте он получает 2,5Кб памяти (стек, куча и служебная информация о процессе).

Виртуальная машина имеет лимит на число процессов, по умолчанию это 262,144 (2^18). Лимит можно увеличить до 134,217,727 (2^27). Но вряд ли кому-то захочется создать 134 млн процессов на одной ноде, тем более, что для этого понадобится 336Гб оперативной памяти :)

Легковесность процессов качественно меняет архитектуру. Процессы не являются ограниченным ресурсом, как в большинстве других языков. Можно легко выделить отдельный процесс (и даже больше) на обслуживание каждого клиента, и позволить клиенту занимать этот процесс сколько угодно долго.

Поэтому типичная область применения BEAM -- это сервера, которые должны обслуживать большое количество клиентов. Особенно если соединения с клиентами являются долгоживущими.


## spawn

Для создания нового процесса используется функция [spawn](TODO link)

iex> spawn(fn -> 1 + 2 end)
#PID<0.43.0>

spawn/1 takes a function which it will execute in another process.

Она имеет несколько вариантов: TODO elixir
Kernel.spawn/1 and Kernel.spawn/3
Process.spawn/2 /4

Так или иначе в аргументах spawn указывается точка входа для нового процесса, с которой он начинает выполнятся. Далее процесс либо выполнит весь код, и завершится; либо попадет в бесконечную рекурсию и будет выполнятся бесконечно; либо завершится аварийно из-за ошибки.

Функция spawn возвращает **Pid** -- идентификатор процесса (process identifier). Зная Pid, можно посылать процессу сообщения и получать информацию о нем.

Although a PID is displayed as three numbers, it contains just two fields; 
the first number is the node ID 
and the next two numbers are the low and high bits of the process ID.

Давайте попробуем запустить несколько процессов:

``` TODO elixir
4> G = fun(X) -> timer:sleep(10), io:format("~p~n", [X]) end.
 #Fun<erl_eval.6.13229925>
5> [spawn(fun() -> G(X) end) || X <- lists:seq(1,10)].
[<0.273.0>,<0.274.0>,<0.275.0>,<0.276.0>,<0.277.0>,
<0.278.0>,<0.279.0>,<0.280.0>,<0.281.0>,<0.282.0>]
2
1
4
3
5
8
7
6
10
9
```

Создаем анонимную функцию, в которой после паузы в 10 миллисекунд выводим на консоль ее аргумент.  С помощью генератора списков создаем 10 процессов. Каждый из них выполняет эту функцию независимо от остальных. Видим, что очередность вывода чисел на консоль не совпадает с очередностью создания процессов. Вывод будет случайным, в зависимости от того, как планировщик раздавал управление процессам.


## Отправка сообщений

Процессы BEAM имеют каждый свою изолированную область памяти (стек и кучу), не читают и не пишут в чужую память, а обмениваются сообщениями.

Для этого используется оператор ! (bang): TODO elixir

```
Pid ! Message
```

Pid должен быть идентификатором процесса, а Message -- любая структура данных или атомарное значение.

Отправка сообщения выполняется асинхронно. То есть, процесс не блокируется и не ждет ответа, а продолжает выполнение. При попытке отправить сообщение несуществующему процессу, сообщение просто игнорируется. Ошибки при этом не происходит.

Процесс может отправить сообщение самому себе.

``` TODO elixir
10> self() ! hello.
hello
11> flush().
Shell got hello
ok
```

