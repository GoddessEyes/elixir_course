+ https://github.com/yzh44yzh/practical_erlang/blob/master/08_concurrency/lesson_08.md
+ https://elixir-lang.org/getting-started/processes.html
- https://hexdocs.pm/elixir/1.12/Process.html
- c3-otp/processes.md
- DT ch 15
- SJ ch 5


# Работа с процессами на низком уровне

Эффективная поддержка многопоточности -- одна из главных фишек виртуальной машины BEAM. И она же является базой для других её своств: масштабируемости, распределенности, устойчивости к ошибкам.


## Легковесные процессы

BEAM имеет собственную реализацию многопоточности поверх процессов операционной системы. На одном системном процессе могут работать сотни и тысячи процессов BEAM.Виртуальная машина управляет ими независимо от операционной системы.

Прежде, чем мы начнем погружаться в эту тему, нужно уточнить терминологию. В разных операционных системах и языках программирования есть разные сущности: 

процесс (process) -- сущность на уровне операционной системы, с которой связаны ряд ресурсов (память, файловые дескрипторы, пользовательские права и др).
поток (thread) -- в рамках одного процесса могут существовать несколько потоков, которые разделяют между собой общие ресурсы.
нить выполнения (grean thread) -- поток, реализованный на уровне виртуальной машины, а не ОС.
TODO (уточнить эти сущности).

Но когда мы говорим про BEAM, то у нас есть только одна сущность. В англоязычной документации и литературе используют термин **process**. В русскоязычной могут встречаться и "процесс" и "поток", но имеется в виду одна и та же сущность. С точки зрения ОС это green thread. Но он существенно отличается от других виртуальных машин, например, от JVM.

Processes are isolated from each other, run concurrent to one another and communicate via message passing.

Особенность процессов BEAM в том, что они легковесные. Это значит, что они:
- быстро стартуют и завершаются;
- быстро переключаются;
- потребляют мало памяти.

Новый процесс создается и стартует за 3-5 микросекунд. На старте он получает 2,5Кб памяти (стек, куча и служебная информация о процессе).

Виртуальная машина имеет лимит на число процессов, по умолчанию это 262,144 (2^18). Лимит можно увеличить до 134,217,727 (2^27). Но вряд ли кому-то захочется создать 134 млн процессов на одной ноде, тем более, что для этого понадобится 336Гб оперативной памяти :)

Легковесность процессов качественно меняет архитектуру. Процессы не являются ограниченным ресурсом, как в большинстве других языков. Можно легко выделить отдельный процесс (и даже больше) на обслуживание каждого клиента, и позволить клиенту занимать этот процесс сколько угодно долго.

Поэтому типичная область применения BEAM -- это сервера, которые должны обслуживать большое количество клиентов. Особенно если соединения с клиентами являются долгоживущими.


## spawn

Для создания нового процесса используется функция [spawn](TODO link)

iex> spawn(fn -> 1 + 2 end)
#PID<0.43.0>

spawn/1 takes a function which it will execute in another process.

Она имеет несколько вариантов: TODO elixir
- spawn(Fun) -> pid()
- spawn(Node, Fun) -> pid()
- spawn(Module, Function, Args) -> pid()
- spawn(Node, Module, Function, Args) -> pid()

Так или иначе в аргументах spawn указывается точка входа для нового процесса, с которой он начинает выполнятся. Далее процесс либо выполнит весь код, и завершится; либо попадет в бесконечную рекурсию и будет выполнятся бесконечно; либо завершится аварийно из-за ошибки.

Функция spawn возвращает **Pid** -- идентификатор процесса (process identifier). Зная Pid, можно посылать процессу сообщения и получать информацию о нем.

Давайте попробуем запустить несколько процессов:

``` TODO elixir
4> G = fun(X) -> timer:sleep(10), io:format("~p~n", [X]) end.
 #Fun<erl_eval.6.13229925>
5> [spawn(fun() -> G(X) end) || X <- lists:seq(1,10)].
[<0.273.0>,<0.274.0>,<0.275.0>,<0.276.0>,<0.277.0>,
<0.278.0>,<0.279.0>,<0.280.0>,<0.281.0>,<0.282.0>]
2
1
4
3
5
8
7
6
10
9
```

Создаем анонимную функцию, в которой после паузы в 10 миллисекунд выводим на консоль ее аргумент.  С помощью генератора списков создаем 10 процессов. Каждый из них выполняет эту функцию независимо от остальных. Видим, что очередность вывода чисел на консоль не совпадает с очередностью создания процессов. Вывод будет случайным, в зависимости от того, как планировщик раздавал управление процессам.


## Отправка сообщений

Процессы BEAM имеют каждый свою изолированную область памяти (стек и кучу), не читают и не пишут в чужую память, а обмениваются сообщениями.

Для этого используется оператор ! (bang): TODO elixir

```
Pid ! Message
```

Pid должен быть идентификатором процесса, а Message -- любая структура данных или атомарное значение.

Отправка сообщения выполняется асинхронно. То есть, процесс не блокируется и не ждет ответа, а продолжает выполнение. При попытке отправить сообщение несуществующему процессу, сообщение просто игнорируется. Ошибки при этом не происходит.

Процесс может отправить сообщение самому себе.

``` TODO elixir
10> self() ! hello.
hello
11> flush().
Shell got hello
ok
```

## Почтовый ящик

У каждого процесса есть специальная область памяти -- почтовый ящик (mailbox), куда копируются адресованные ему сообщения. Там сообщения накапливаются в очереди, в порядке их появления.

Чтобы прочитать сообщения в почтовом ящике, нужно использовать конструкцию **receive**.

``` TODO elixir
receive
    Pattern1 [when Guard1] ->
        Expressions1;
    Pattern2 [when Guard2] ->
        Expressions2;
    ...
end
```

Синтаксис аналогичен конструкции **case**.

В этом примере процесс отправляет сообщение самому себе, и получает его с помощью receive:

``` TODO elixir
12> self() ! "hello again".
"hello again"
13> receive
13> Msg -> io:format("got message:~p~n", [Msg])
13> end.
got message:"hello again"
ok
```

При вызове receive процесс берет сообщение из очереди и сопоставляет его с имеющимися шаблонами. Если находится подходящий шаблон, то выполняется соответствующий блок кода, и затем код после receive. А сообщение удаляется из почтового ящика. Другие сообщения в почтовом ящике остаются до следующего вызова receive.  Если сообщение не совпало ни с одним шаблоном, то оно остается в очереди, и для проверки берется следующее.

TODO оставить это? Смотря сколько наберется практики. Если не слишком много, то можно оставить.

Чтобы четко разобраться, как работает receive в разных ситуациях, сделаем тест.  Будем отправлять разные сообщения, и с помощью receive будем выбирать только те, которые соответствуют шаблону **{msg, Any}**.

https://github.com/yzh44yzh/practical_erlang/blob/master/08_concurrency/mb.erl

```
-module(mb).
-export([test/0]).

test() ->
    test_messages("test1, ящик пустой", []),

    test_messages("test2, одно сообщение, матчится",
                  [{msg, 1}]),

    test_messages("test3, одно сообщение, не матчится",
                  [msg1]),

    test_messages("test4, 3 сообщения, все матчатся",
                  [{msg, 1}, {msg, 2}, {msg, 3}]),

    test_messages("test5, 3 сообщения, все не матчатся",
                  [msg1, msg2, msg3]),

    test_messages("test6, 4 сообщения, часть матчится, часть не матчится",
                  [{msg, 1}, msg2, {msg, 3}, msg4]),

    test_messages("test7, 4 сообщения, часть матчится, часть не матчится",
                  [msg1, {msg, 2}, msg3, {msg, 4}]),

    ok.

test_messages(TestName, Messages) ->
    io:format("~n### ~ts~ntest_messages: ~p~n", [TestName, Messages]),
    flush(),
    [self() ! Msg || Msg <- Messages],

    io:format("call receive~n"),
    Res = receive
              {msg, M} -> {msg, M}
          after 100 -> timeout
          end,
    io:format("after receive got: ~p~n", [Res]),
    [{messages, Left}] = process_info(self(), [messages]),
    io:format("left in mailbox: ~p~n", [Left]),
    ok.

flush() ->
    receive
        _ -> flush()
    after 100 -> ok
    end.
```

Функция **flush/0** очищает почтовый ящик перед каждым тестом, для чистоты эксперимента.

По результатам теста мы видим, что receive выбирает одно сообщение, совпадающее с шаблоном, если такое есть. Если нет, то процесс блокируется.

В тесте этого не видно, но процесс блокируется либо на указанное время, либо до получения подходящего сообщения.

Почтовый ящик -- самая частая причина утечки памяти в BEAM. Если receive не вызывается, или вызывается, но обрабатывает не все сообщения, то утечка памяти неизбежна. Кроме того, по мере роста очереди, каждый проход по ней становится все медленнее и медленнее.

Эликсир и эрланг разработчики об этом знают. И если обнаруживается утечка памяти, то диагностика проблемы начинается с очередей в почтовых ящиках.

Хорошая практика -- делать в receive последний шаблон такой, чтобы он совпадал с любым сообщением. И в этом случае писать в лог о том, что процесс получил сообщение, которое он не умеет обрабатывать.

``` TODO elixir
receive
    {do_something, Data} -> do_something(Data);
    Any -> lager:warning("Got unknown message ~p", [Any])
end,
```

Это уменьшит вероятность проблем с почтовым ящиком. Но не гарантирует полностью их отсутствие. Возможно ситуация, когда сообщения поступают быстрее, чем процесс успевает их обрабатывать. Увы, но универсального рецепта для таких ситуаций нет :)


## timeout

В тесте выше уже использовался таймаут, но нужно подробнее его объяснить.

``` TODO elixir
receive
    {do_something, Data} -> do_something(Data);
end,
```

Здесь, если нет подходящего по шаблону сообщения, процесс заблокируется и будет ждать, пока сообщение появится. А если оно никогда не появится, то процесс так и останется заблокированным.

Поэтому разумно указать максимальное время, на которое можно заблокировать процесс.

``` TODO elixir
receive
    {do_something, Data} -> do_something(Data);
after
    5000 -> exp1
end,
```

Это либо целое число -- время в милисекундах, либо атом infinity. Впрочем, infinity аналогично отсутствию after.


## Регистрация процессов

Pid -- штука хорошая, но не всегда удобная. Если мы хотим посылать сообщения в процесс из нескольких других процессов, нам придется как-то передать всем им Pid получателя.

Но есть альтернатива -- процессу можно дать некое имя, глобальное на уровне всей ноды, и потом обращаться к нему по этому имени.

``` TODO elixir
register(Name, Pid)
```

Вызов register сгенерирует исключение, если имя уже связано с другим процессом.

Регистрацию процесса можно отменить:

``` TODO elixir
unregister(Name)
```

Можно узнать все имена зарегистрированных процессов, какие есть в ноде:

``` TODO elixir
registered()
```

И можно узнать Pid процесса по имени:

``` TODO elixir
whereis(Name)
```

Пробуем: 

``` TODO elixir
1> registered().
[erl_prim_loader,error_logger,kernel_safe_sup,init,user,rex,
 inet_db,kernel_sup,code_server,standard_error_sup,
 global_name_server,application_controller,file_server_2,
 user_drv,standard_error,global_group]
2> register(erl_console, self()).
true
3> registered().
[erl_prim_loader,error_logger,kernel_safe_sup,init,user,rex,
 inet_db,kernel_sup,code_server,standard_error_sup,
 global_name_server,erl_console,application_controller,
 file_server_2,user_drv,standard_error,global_group]
4> whereis(erl_console).
<0.33.0>
5> self().
<0.33.0>
6> unregister(erl_console).
true
```


## Выводы

Легкие процессы, обмен сообщениями, отсутсвие разделяемой памяти дают хорошую базу для:
- масштабируемости;
- распределенности;
- устойчивости к ошибкам.

Поскольку процессы -- дешевый ресурс, их можно создавать в количестве, адекватном нагрузке на систему, и менять вместе с изменением нагрузки.

Если мы умеем передавать сообщения от одного процессы другому в рамках одной ноды, то не сложно это делать и между двумя нодами. Нужен только транспорт поверх TCP, и в виртуальной машине  этот транспорт есть.

Поскольку процессы изолированы друг от друга, то падение одного процесса не влияет на работу других процессов.  Впрочем, устойчивость к ошибкам не появляется сама по себе, программисту еще нужно постараться, чтобы этого добиться :)
