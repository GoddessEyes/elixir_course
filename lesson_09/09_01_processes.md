# Работа с процессами на низком уровне

Эффективная поддержка многопоточности -- одна из главных фишек виртуальной машины BEAM. Она же является базой для других её своств: масштабируемости, распределенности, устойчивости к ошибкам.


## Процессы и потоки

Прежде, чем мы начнем погружаться в BEAM, уточним терминологию, иначе мы рискуем запутаться в понятиях "процесс" и "поток".

Когда мы говорим об операционной системе (не о BEAM), то нужно различать три сущности: процесс (process), поток (thread) и зеленый поток (green thread).

**Процесс** является основой многопоточности. Это довольно "тяжелая" сущность в том смысле, что с процессом связано довольно много разных ресурсов: адресное пространство, контекст (код, стек, состояние регистров), файловые дескрипторы (в т.ч. стандартный ввод-вывод), сокеты, пользовательские права. Создание процесса -- это относительно дорогая операция. И количество процессов, которые можно создать, ограничено.

**Поток** (он еще может называться "нить выполнения") -- это "легковесная" сущность. С ним связано горазо меньше ресурсов, и его создание намного дешевле. Обычно в рамках одного процесса могут существовать несколько потоков, которые разделяют между собой общие ресурсы процесса.

Процессы изолированы друг от друга и взаимодействуют через механизмы, предоставляемые ОС. Потоки не изолированы и взаимодействуют через общую память.

Еще есть **зеленые потоки** (grean thread). Они отличаются тем, что реализованы на уровне библиотеки или виртуальной машины, и работают в пользовательском пространстве. ОС про них не знает и не управляет ими. Они еще более "легковестны", так как создание и управление ими не требует системных вызовов. У них, однако, есть недостатки: если один из потоков делает системный вызов, например, для работы со стандартным вводом-выводом, то это блокирует все потоки в рамках одного процесса. Аварийное завершение потока приводит к завершению родительского процесса, и всех потоков в нем.

Теперь, если мы говорим про BEAM, то по сути мы имеем дело с зелеными потоками. Однако реализация потоков в BEAM лишена перечисленных выше недостатков. Они изолированы друг от друга, не блокируют друг друга, и авария одного потока не приводит к авариям других потоков. При этом сохраняется их "легковестность".

В документации Эликсира и Эрланга *потоки* BEAM принято называть *процессами*. Что несколько противоречит терминологии на уровне ОС. Дальше в курсе я тоже буду называть их *процессами*.


## Легковесные процессы BEAM

BEAM имеет собственную реализацию многопоточности поверх процессов операционной системы. На одном системном процессе могут работать сотни и тысячи процессов BEAM. Виртуальная машина управляет ими независимо от операционной системы.

Processes are isolated from each other, run concurrent to one another and communicate via message passing.

Isolated:
- don't share memory
- don't block each other from running
- one processes crash don't crash other processes (except we want it happens)


Особенность процессов BEAM в том, что они легковесные. Это значит, что они:
- быстро стартуют и завершаются;
- быстро переключаются;
- потребляют мало памяти.

Новый процесс создается и стартует за 3-5 микросекунд. На старте он получает 2,5Кб памяти (стек, куча и служебная информация о процессе).

Виртуальная машина имеет лимит на число процессов, по умолчанию это 262,144 (2^18). Лимит можно увеличить до 134,217,727 (2^27). Но вряд ли кому-то захочется создать 134 млн процессов на одной ноде, тем более, что для этого понадобится 336Гб оперативной памяти :)

Легковесность процессов качественно меняет архитектуру. Процессы не являются ограниченным ресурсом, как в большинстве других языков. Можно легко выделить отдельный процесс (и даже больше) на обслуживание каждого клиента, и позволить клиенту занимать этот процесс сколько угодно долго.

Поэтому типичная область применения BEAM -- это сервера, которые должны обслуживать большое количество клиентов. Особенно если соединения с клиентами являются долгоживущими.


## spawn

Для создания нового процесса используется функция [spawn](TODO link)

iex> spawn(fn -> 1 + 2 end)
#PID<0.43.0>

spawn/1 takes a function which it will execute in another process.

Она имеет несколько вариантов: TODO elixir
Kernel.spawn/1 and Kernel.spawn/3
Process.spawn/2 /4

Так или иначе в аргументах spawn указывается точка входа для нового процесса, с которой он начинает выполнятся. Далее процесс либо выполнит весь код, и завершится; либо попадет в бесконечную рекурсию и будет выполнятся бесконечно; либо завершится аварийно из-за ошибки.

Функция spawn возвращает **Pid** -- идентификатор процесса (process identifier). Зная Pid, можно посылать процессу сообщения и получать информацию о нем.

Although a PID is displayed as three numbers, it contains just two fields; 
the first number is the node ID 
and the next two numbers are the low and high bits of the process ID.

Давайте попробуем запустить несколько процессов:

``` TODO elixir
4> G = fun(X) -> timer:sleep(10), io:format("~p~n", [X]) end.
 #Fun<erl_eval.6.13229925>
5> [spawn(fun() -> G(X) end) || X <- lists:seq(1,10)].
[<0.273.0>,<0.274.0>,<0.275.0>,<0.276.0>,<0.277.0>,
<0.278.0>,<0.279.0>,<0.280.0>,<0.281.0>,<0.282.0>]
2
1
4
3
5
8
7
6
10
9
```

Создаем анонимную функцию, в которой после паузы в 10 миллисекунд выводим на консоль ее аргумент.  С помощью генератора списков создаем 10 процессов. Каждый из них выполняет эту функцию независимо от остальных. Видим, что очередность вывода чисел на консоль не совпадает с очередностью создания процессов. Вывод будет случайным, в зависимости от того, как планировщик раздавал управление процессам.


## Отправка сообщений

Процессы BEAM имеют каждый свою изолированную область памяти (стек и кучу), не читают и не пишут в чужую память, а обмениваются сообщениями.

Для этого используется оператор ! (bang): TODO elixir

```
Pid ! Message
```

Pid должен быть идентификатором процесса, а Message -- любая структура данных или атомарное значение.

Отправка сообщения выполняется асинхронно. То есть, процесс не блокируется и не ждет ответа, а продолжает выполнение. При попытке отправить сообщение несуществующему процессу, сообщение просто игнорируется. Ошибки при этом не происходит.

Процесс может отправить сообщение самому себе.

``` TODO elixir
10> self() ! hello.
hello
11> flush().
Shell got hello
ok
```

