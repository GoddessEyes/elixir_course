# Что такое монада?

В 7-м уроке мы пытались ответить на вопрос "что такое функциональное программирование?". Мы говорили, что есть элементы ФП, такие как иммутабельность, рекурсия, функции высшего порядка, сопоставление с образцом и др. И функциональное программирование -- это то, что состоит **в основном** из этих элементов.

Теперь мы попробуем копнуть глубже, и разобраться, что такое **монада**. Есть шутка, что каждый новичок, приходящий в Хаскель, обязательно придумывает своё объяснение монад. Таких объяснений существует действительно много. И часто они слишком абстрактны, не дают понимания, какая от всего этого практическая польза.

Поэтому мы начали не с теории, а с практики. Мы уже применили монады и операции над ними, решили с их помощью прикладную задачу. После этого проще понять теорию.


## Примеры монад

Монада -- это значение, обернутое в некоторый полезный контекст. Например:

```
{:ok, book} = BS.Book.get_book(author, title)
```

Здесь значение `book` обернуто в контекст `{:ok, book}`, и этот контекст несет информацию о том, что получен успешный результат.

```
{:error, {:book_not_found, title}} = BS.Book.get_book(author, title)
```

Здесь значение `{:book_not_found, title}` обёрнуто в контекст `{:error, ...}`, и этот контекст несет информацию о том, что получена ошибка.

Это монада **Result**, которая описывается типом:

```
{:ok, successful_value} | {:error, error_value}
```

Это одна из самых популярных монад, она есть практически во всех ФП языках и во многих не ФП языках:
- Haskell `Result e t`
- OCaml `('a, 't) result`
- Rust `Result<T, E>`
- Scala `Either[E, T]`

Другая популярная монада -- **Maybe**. Здесь контекст несет информацию о том что значение существует или не существует:

```
> m = %{a: 42}
> Map.fetch(m, :a)
{:ok, 42}
> Map.fetch(m, :b)
:error
```

**Maybe** описывается типом:

```
{:ok, value} | :error
```

Как видим, это упрощенный Result. Здесь есть `successful_value`, но нет `error_value`, а только сам контекст `:error`.

Еще одна полезная монада -- **Feature**. Здесь контекст несет информацию о том, что значения прямо сейчас нет, но оно когда-нибудь будет, когда завершится асинхронное вычисление:

```
iex(5)> feature_value = Task.async(fn() -> 42 end)
%Task{
  owner: #PID<0.107.0>,
  pid: #PID<0.113.0>,
  ref: #Reference<0.3496306138.1615593474.196666>
}
iex(6)> Task.await(feature_value)
42
```

## Оператор bind

Вспомним тему урока -- композиция функций. Вспомним 4-е решение, где мы реализовали функцию bind:

```
def bind(f1, f2) do
  fn(args) ->
    case f1.(args) do
      {:ok, res} -> f2.(res)
      {:error, reason} -> {:error, reason}
    end
  end
end
```

и применили ее для композиции функций:

```
f = FP.bind(FP.bind(FP.bind(FP.bind(
    &V.validate_incoming_data/1, &validate_cat/1), &validate_address/1), &validate_books/1), &create_order/1)
f.(BookShop.test_data)
```

Увы, в Эликсире нельзя сделать как в Хаскеле, в префиксном виде:

```
f = validate_incoming_data >>= validate_cat >>= validate_address >>= validate_books >>= create_order
f test_data
```

Но тем не менее bind работает. И что он делает? Он принимет монаду Result, извлекает значение из контекста, и в зависимости от контекста либо вызывает следующую функцию, либо просто возвращает значение.

bind -- это операция над монадой, она нужна для композиции функций.

Мы могли бы реализовать аналогичный bind для Maybe, но это слишком тривиально. Или bind для Feature, и это уже интереснее.

Представим, что у нас есть несколько асинхронных функций, которые делают запросы в разные сервисы. Нам нужно сделать несколько запросов, получить все результаты, и сделать некий суммарный результат:

```
feature1 = request_service_1()
value1 = Task.await(feature1)

feature2 = request_service_2()
value2 = Task.await(feature2)

feature3 = request_service_3()
value3 = Task.await(feature3)
```

Мы могли бы реализовать bind, извлекающий значение из Feature, и сделать композицию функций:

```
request_service_1() >>= request_service_2() >>= request_service_3()
```

Причем, это может быть простая реализация, которая делает 3 блокировки по-очереди, или сложная реализация, которая видит композицию всех функций как единое целое, запускает все 3 запроса одновременно, и отдаёт результаты за время, равной одной самой долгой блокировке.

Польза от Result и Feature очевидна. Но почему они собраны в некую общую группу с названием "монады"? Что их объединяет? Как мы видим, их объединяет возможность делать композицию функций с помощью bind.

Вспомним протоколы Enumerable, Inspect, String.Chars и др. Они позволяют делать одинаковые операции над разными типами данных. Если бы в эликсир существовал протокол Monad, то можно было бы использовать один bind для всех монад. В Хаскеле это так и есть.

(В языке и стандартной библиотеке Эликсир нет монад, но есть библиотека [Monad](https://hexdocs.pm/monad/Monad.html) реализующая некоторые монады и операции над ними.


## Другие операции над монадами

Давайте обозначим простое значение `v`, а значение обернутое в монаду `M<v>`.

У нас могут быть функции:

```
f1(v) :: v
f2(v) :: M<v>
f3(M<v>) :: v
f4(M<v>) :: M<v>
```

Все эти варианты нужно комбинировать между собой. 

bind работает для f2: `f2 >>= f2`.

Для f1 и f4 подходит обычный pipe: `f1 |> f1`, `f4 |> f4`.

Для f3 нужно нечто противоположное bind. Что-то, что заворачивает простое значение в монаду. В Хаскеле для этого есть оператор `return`. (Название, конечно, сбивает с толку, тут return  не имеет никакого отношения к возврату значения.)

Для монады Result оператор return (если бы он существовал в Эликсир), работал бы так:

```
def return(val), do: {:ok, val}
```

И композиция функций выглядела бы так `f3 return f3`. 

Для f1 и f4 в Хаскеле предусмотрены разные операторы: `f1 . f1`, `f4 >> f4`. Но в Эликсир нам это не нужно.


## Функциональная программа -- это композиция функций

В теории любая функциональная программа сводится к цепочке функций, скомпонованых друг с другом разными способами:

```
Fun1 >>= Fun2 . Fun3 >> Fun4 >>= Fun5 . Fun6
```

В этой цепочке обрабатываются все возможные выходы: позитивные результаты и ошибки, и все побочные эффекты. 

Если пойти по этому пути, то мы столкнемся с монадами, вложенными друг в друга:

```
Result<Maybe<v>>
Feature<Maybe<Result<v>>>
```

и с монадными трансформерами, которые позволяют работать с такими значениями. 

Но я про это рассказывать не буду. Во-первых, потому что для Эликсир это не очень актуально. Во-вторых, потому что сам в этом не разбираюсь :)

Скажу только, что наша функция `FP.sequence/1` является монадным трансформером. Она преобразует `[ Result<Book.t, Error> ]` в `Result< [Book.t], Error>`. То есть, преобразует список над Result в Result над списком.

В 80-90-х годах победило императивное программирование. Это случилось потому, что оно гораздо эффективнее использовало имеющиеся ресурсы: CPU и память. А ресурсы тогда были в дефиците.

Если бы тогда победило функциональное программирование, то сегодня код выглядел бы совершенно иначе :)
