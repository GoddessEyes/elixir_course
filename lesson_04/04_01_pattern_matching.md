# Сопоставление с образцом (Pattern Matching)

Одна из главных особенностей функционального программирования -- сопоставление с образцом. Применяется очень широко, так что вряд ли можно найти такую программу на функциональном языке, где нет pattern matching.

Сопоставление с образцом используется для:
- присвоения значений переменным;
- извлечения значений из сложных структур данных;
- условных переходов.

Рассмотрим все эти случаи на примерах.


## Присвоение значений переменным

```elixir-iex
iex(1)> a = 123
123
iex(2)> a
123
```

Эта элементарная конструкция, которая выглядит, как присваивание значения переменной, на самом деле не является присваиванием. Присваивания в Эликсире нет, а оператор `=` называеся оператором сопоставления (match operator).

В данном коде значение справа -- `123` -- сопоставляется с шаблоном слева -- переменной `a`. И поскольку шаблон соответствует значению, то сопоставление происходит успешно, и переменная `а` связывается со значением.

![Match Operator](./img/match_operator.png)

Однако, это тривиальный случай. Чтобы понять PM нужно рассмотреть более сложные случаи.

Совпадение по значению:
```
42 = 42 # ok
20 = 42 # badmatch
```

Совпадение нескольких значений:
```
{:ok, 42, 100} = {:ok, 42, 100} # ok
{:ok, 42, 100} = {:ok, 42, 200} # badmatch
```

Использование переменных в шаблоне:
```
{:ok, a, b} = {:ok, 42, 100} # ok
```

Совпадение по структуре:
```
{:ok, a, b} = {:ok, 42, 100, 500} # badmatch
{:ok, a, b} = {:ok, 42, {100, 500}} # ok
{:ok, a, {b, c}} = {:ok, 42, {100, 500}} # ok
```

## Извлечение значений из сложных структур данных

```elixir-iex
iex(3)> user = {:user, "Bob", 25}
{:user, "Bob", 25}
iex(4)> {:user, name, age} = user
{:user, "Bob", 25}
iex(5)> name
"Bob"
iex(6)> age
25
```

В первой строке всё значение справа целиком присваивается в переменную слева.

А вот вторая строка уже интереснее. Слева от оператора `=` шаблон, который ограничивает множество значений. Этот шаблон может совпасть только с такими значениями, которые являются кортежами из трех элементов, и первым элементом обязательно должен быть атом `:user`, а второй и третий элемент могут быть любыми.

Справа от оператора `=` находится значение, которое мы сравниваем с шаблоном. В данном случае значение извлекается из переменной `user`, но оно может быть и результатом вызова функции или литералом.

Сопоставление проходит успешно, и в результате переменные шаблона `name` и `age` получают значения `"Bob"` и `25`.

В случае, если значение не совпадает с шаблоном, возникает исключение:

```elixir-iex
iex(7)> {:user, name, age} = {:dog, "Sharik", 5}
** (MatchError) no match of right hand side value: {:dog, "Sharik", 5}
iex(7)> {:user, name, age} = {:user, "Bob", 25, :developer}
** (MatchError) no match of right hand side value: {:user, "Bob", 25, :developer}
```

Первое значение не совпало, потому что `:dog != :user`. Второе значение не совпало, потому что в кортеже 4 элемента, а не 3.

И значение, и шаблон могут быть сложными структурами с любой глубиной вложенности:

```elixir
users = [
{:user, "Bob", :developer, {:lang, ["Erlang", "Elixir"]}},
{:user, "Bill", :developer, {:lang, ["Python", "JavaScript"]}},
{:admin, "Stan", :developer, {:lang, ["Scala", "PHP"]}}
]

[{:user, _, _, _}, {:user, name, _, {:lang, [lang1, lang2]}}, _] = users
[
  {:user, "Bob", :developer, {:lang, ["Erlang", "Elixir"]}},
  {:user, "Bill", :developer, {:lang, ["Python", "JavaScript"]}}
]
iex(14)> name
"Bill"
iex(15)> lang1
"Python"
iex(16)> lang2
"JavaScript"
```

Здесь у нас список из двух элементов. Каждый элемент является кортежем из 4х элементов. 4-й элемент кортежа, это вложенный кортеж. И в нем еще один вложенный список. Наш шаблон повторяет всю эту структуру и извлекает значения из 4-го уровня вложенности.

Обратите внимания на символ подчеркивания. Он совпадает с любым значением и применяется, когда это значение не нужно, мы не хотим сохранять его в переменную.

Если переменная встречается два раза, то значения в этих местах должны быть одинаковыми:

```elixir-iex
iex(20)> {a, a, 42} = {10, 10, 42}
{10, 10, 42}
iex(21)> {a, a, 42} = {20, 20, 42}
{20, 20, 42}
iex(22)> {a, a, 42} = {10, 20, 42}
** (MatchError) no match of right hand side value: {10, 20, 42}
```

Но это не касается символа подчеркивания:

```elixir-iex
iex(22)> {_, _, 42} = {10, 10, 42}
{10, 10, 42}
iex(23)> {_, _, 42} = {20, 20, 42}
{20, 20, 42}
iex(24)> {_, _, 42} = {10, 20, 42}
{10, 20, 42}
```


## Как устроен Pattern Matching

Теперь формализуем то, что мы узнали. Итак, у нас есть оператор сопоставления `=`, слева от него -- шаблон, и справа -- значение.

```
[pattern] = [value]
```

Шаблон может включать:
- литералы
- переменные
- универсальный шаблон (символ подчеркивания)

Значение может включать:
- литералы
- переменные
- выражения

Литералы в шаблоне слева должны совпасть с литералами, переменными и результатами вычисления значений справа. Все в целом должно совпасть по структуре. Тогда переменные в шаблоне слева получают свои значения из соответствующих позиций справа. Универсальный шаблон совпадает с чем угодно.


## pin operator

Переменная в шаблоне может выполнять две роли. Либо мы хотим, чтобы эта переменная получила новое значение, и тогда не важно, использовалась ли эта переменная раньше, было ли у нее какое-то значение. Либо мы хотим использовать значение, которое переменная уже имеет, как часть шаблона. Во втором случае понадобится pin operator.

```elixir-iex
iex(1)> animal = :cat
:cat
iex(2)> {^animal, "Tihon"} = {:cat, "Tihon"}
{:cat, "Tihon"}
iex(3)> {^animal, "Tihon"} = {:dog, "Tihon"}
** (MatchError) no match of right hand side value: {:dog, "Tihon"}
```

pin operator извлекает текущее значение переменной и подставляет его в шаблон. И дальше это значение в шаблоне работает, как литерал.


## Условные переходы

Сопоставление с образцом также используется для ветвлений в коде (условных переходов):
- конструкция case
- клозы функций (function clause)
- обработка исключений (resque, catch)
- чтение сообщений из mailbox (receive)

Конструкции case и function clause рассмотрим в следущей теме. Обработка исключений и чтение сообщений будут позже в курсе.
