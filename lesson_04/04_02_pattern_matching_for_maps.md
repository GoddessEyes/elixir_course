# Сопоставление с образцом для словарей (map).

Есть некоторые нюансы сопоставления с образцом при работе со словарями. В шаблоне не нужно перечислять все ключи, какие есть в словаре. Мы указываем только те ключи, которые нам нужны:

```elixir
iex(4)> my_map = %{a: 1, b: 2, c: 3}
%{a: 1, b: 2, c: 3}
iex(5)> %{a: value} = my_map
%{a: 1, b: 2, c: 3}
iex(6)> value
1
```

Если ключи не являются атомами, то синтаксис отличается:

```elixir
iex(7)> my_map = %{"a" => 1, "b" => 2, "c" => 3}
%{"a" => 1, "b" => 2, "c" => 3}
iex(8)> %{"a" => value1} = my_map
%{"a" => 1, "b" => 2, "c" => 3}
iex(9)> %{"a" => value1, "b" => value2} = my_map
%{"a" => 1, "b" => 2, "c" => 3}
iex(10)> value1
1
iex(11)> value2
2
```

Шаблон `%{}` совпадает с любым словарём. Это контринтуитивно, можно было бы ожидать, что этот шаблон совпадает только с пустым словарём. Этим шаблоном нельзя ничего извлечь, но можно проверить, что значение является словарём, а не чем-то иным.

```elixir
iex(13)> %{} = my_map
%{"a" => 1, "b" => 2, "c" => 3}
```

  Переменные можно использовать для извлечения значений, но не для извлечения ключей:

```elixir
iex(15)> %{"c" => my_var} = my_map
%{"a" => 1, "b" => 2, "c" => 3}
iex(16)> my_var
3
iex(17)> %{my_var => 1} = my_map
** (CompileError) iex:17: cannot use variable my_var as map key inside a pattern.
```

А _pin_ operator можно использовать и для ключа, и для значения:

```elixir
iex(18)> value1
1
iex(19)> %{"a" => ^value1} = my_map
%{"a" => 1, "b" => 2, "c" => 3}
iex(20)> keyb = "b"
"b"
iex(21)> %{^keyb => _} = my_map
%{"a" => 1, "b" => 2, "c" => 3
```

