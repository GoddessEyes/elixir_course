# Важные свойства BEAM

Эрланг и Эликсир объединяет виртуальная машина BEAM (Bogdan's Erlang Abstract Machine). Оба языка компилируются в один байткод, который исполняет эта машина. 

BEAM представляет собой операционную систему в миниатюре, она реализует:
- планировщик процессов, 
- управление памятью, 
- ввод-вывод, 
- сетевой стек 
- и много других фич. 
Она даже может запускаться на железе без родительской ОС.

Во всех книгах и документации по Erlang/BEAM указаны 4 базовых свойства машины:
- Многопоточность (Concurrency);
- Устойчивость к ошибкам (Fault Tolerance);
- Поддержка распределенных систем (Distribution); 
- Горячее обновление кода (Hot Code Upgrade).

К базовым свойствам можно добавить еще несколько:
- Симметричная многопроцессорность (Symmetric Multiprocessing);
- Модель акторов (Actor Model);
- Система реального времени (Soft Real Time);
- Сборщик мусора (Garbage Collector);
- Интерактивная консоль (Erlang/Elixir Shell);
- Трассировка (Tracing).

Многие из этих свойств так или иначе реализованы в виртуальных машин других языков: Java, .NET, JavaScript. Но совокупность этих свойств и особенности реализации делает BEAM уникальной и дает Эрланг/Эликсир разработчикам определенные преимущества.


## Многопоточность (Concurrency)

_Что такое многопоточность, какие бывают виды многопоточности, и какие из них реализованы в BEAM мы будем рассматривать позже. А сейчас быстрый обзор._  

BEAM реализует свои потоки (thread) и планировщики (scheduler), независимые от ОС. Эти потоки легковесны, их можно создавать десятки и сотни тысяч. Запуск потоков и переключение между ними происходит очень быстро.

Rаждый поток имеет свою изолированную память. Разделяемой памяти между потоками нет (с некоторыми оговорками).

Ошибки в потоках также изолированы, блокировка или падение одного потока не влияет на работу остальных.

Данные между потоками передаются путем "отправки сообщений" (message passing). При этом данные копируются из памяти одного потока в память другого.

Немного цифр:

BEAM способна запускать до **134,217,727 (2^27)** потоков. По умолчанию установлено ограничение в **262,144 (2^18)** потоков. Этого обычно хватает, но если нужно больше, то ограничение можно увеличить в настройках BEAM.

Запуск нового потока занимает **3-5** микросекунд. На старте поток резервирует **2696** байт памяти, включая стек, кучу и метаданные. 

BEAM запускает несколько планировщиков, соответственно количеству процессорных ядер. Каждый планировщик использует один процесс ОС, и поверх него запускает эрланговские потоки.

Планировщики умеют балансировать нагрузку, перераспределяя потоки между собой. У них нет задачи постоянно держать равномерную нагрузку на все ядра процессоров, но есть задача избежать больших перекосов, когда одно ядро загружено на 100%, а другое вообще простаивает.


## Устойчивость к ошибкам (Fault Tolerance)

В большинстве языков обработка ошибок реализуется через механизм исключений. Разработчик может получить относительно безопасный код, если сможет предвидеть все возможные ошибки, правильно расставит try…catch и правильно обработает исключения.

BEAM тоже поддерживает исключения, но это не основной способ обработки ошибок. Если вы возьмете исходники какого-нибудь крупного известного эрланг проекта, например, Cowboy или Riak, и поищите там try..catch, то найдете их очень мало.

Основной способ -- это механизм мониторинга одних потоков другими. BEAM имеет специальные потоки, которые сами не выполняют полезной работы, а наблюдают за другими. Они называются **supervisor** (наблюдатели). А потоки, которые выполняют реальную работу, называются **worker** (рабочие).

Если в рабочем потоке возникает ошибка, он аварийно завершается. Супервизор получает об этом сообщение, и может принять какие-то меры. Стандартная мера -- логировать ошибку и перезапустить рабочий поток заново. При этом мы имеем потери -- текущее состояние памяти потока, но можем продолжать работу.

Супервизоры наблюдают не только за рабочими потоками, но и друг за другом. Для этого все потоки организованы в дерево, где узлами являются супервизоры, а листьями – рабочие потоки.  В более сложной ситуации можно перегрузить всю ветвь дерева, выше и выше по уровню. И, наконец, все дерево целиком.

Есть еще один уровень устойчивости к ошибкам -- объединение узлов в кластер. Если узел все-таки падает, или вообще сервер выходит из строя из-за проблем с железом, то его функцию может взять на себя резервный узел.


## Поддержка распределенных систем (Distribution)

Распределенные системы -- одна из самых сложных областей в программировании. BEAM, Эрланг и Эликсир предлагают некоторые важные средства для разработки таких систем.

Распределенность является необходимым условием для устойчивости к аппаратным авариям, что является одним из требований к BEAM. Железо выходит из строя не так часто, но это случается. Если инфраструктура состоит из сотен серверов, то это случается регулярно, и является штатной ситуацией.

Кроме этого, распределенность обеспечивает горизонтальное масштабирование, и позволяет строить большие системы, справляющиеся с большими нагрузками и большими данными.

Одно из важных свойств кластера, состоящего из узлов BEAM, это **сетевая прозрачность** (location transparency). Потоки передают сообщения друг другу не зависимо от того, находятся ли они на одном узле, или на разных.

BEAM обеспечивает транспорт прозрачно для программиста: открывает сокеты, устанавливает TCP соединения между узлами и мониторит их состояние. О всех этих низкоуровневых вещах программисту думать не нужно.

BEAM-узлы, собранные в кластер, формируют доверенную среду (trusted environment). Любой поток может посылать любые сообщения кому угодно. И любой код выполняется с равными правами, без ограничений. Это удобно, но не безопасно. Подразумевается, что все узлы находятся в одной локальной сети, и сеть защищена от внешнего мира.


## Горячее обновление кода (Hot Code Upgrade)

TODO stopped here

Эрланг позволяет загрузить в рантайм новую версию кода модуля,
и переключить выполнение потока со старой версии на новую,
сохранив состояние его памяти.

Если в коде изменились структуры данных,
то есть способ мигрировать данные из старой структуры в новую.

Еще может измениться дерево супервизоров, и нужно стартовать новые потоки,
или завершать старые.

Эти проблемы так или иначе решаются.


## Симметричная многопроцессорность (Symmetric Multiprocessing)

С 2006 года одна эрланг умеет эффективно использовать все процессорные ядра в системе,
и перераспределять нагрузку между ними.

То есть, поток, запущенный под одним планировщиком, на одном процессорном ядре, может быть
передан под управление другому планировщику, и продолжить выполнение на другом процессором ядре.

Это позволяет избежать ситуаций, когда одно ядро загружено на 100%, а другое простаивает.

Причем, это справедливо для систем с большим количеством ядер. Например, его запускали
на чипах с 1024 ядрами, и эрланг эффективно использовал ресурс всех этих ядер.

Erlang Scheduler Details and Why It Matters
https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html


## Модель акторов (Actor Model)

https://en.wikipedia.org/wiki/Actor_model

Один из способов реализации многопоточности.

Система состоит из акторов, которые действуют паралельно и независимо друг от друга.

Акторы общаются друг с другом с помощью отправки сообщений (message passing).
Один поток может послать другому любые данные.
При этом данные копируются, и получающий поток никак не может повлиять на данные отправителя.

Отправка сообщений является асинхронной.
При необходимости можно реализовать синхронный вызов -- блокировать поток на какое-то время, и ждать, пока придет ответное сообщение.

Каждый актор имеет mailbox, где накапливаются полученные им сообщения.
Это специальная область памяти потока.
Поток проверяет свой mailbox, когда считает нужным, и реагирует на сообщения, как считает нужным.

Для некоторых языков модель акторов реализована как библиотека.
Например, библиотека Akka http://akka.io/ для Scala и Java.

Но в эрланг эта модель реализована в виртуальной машине и поддерживается непосредственно на уровне языка.


## Система реального времени (Soft Real Time)

https://en.wikipedia.org/wiki/Real-time_computing

На эрланг можно строить системы реального времени -- то есть, системы, где требуется предсказуемое время ответа.

Это возможно благодаря:
- вытесняющей многозадачности (preemptive scheduling);
- настраиваемому IO;
- особенностям сборки мусора (garbage collection).

Да, планировщики в эрланг реализуют вытесняющую многозадачность.

IO не выполняется в каждом потоке отдельно, а выполняется через специализированный пул потоков,
и его можно тонко настраивать.

Про сборку мусора поговорим отдельно.


## Сборщик мусора (Garbage Collector)

Сборка мусора в функциональных языках несколько проще, чем в
императивных, благодаря неизменяемым переменным.  Из-за этого точно
известно, что переменные, созданные раньше, не могут указывать на
объекты, созданные позже.

Сборщик мусора в Erlang делит объекты на два поколения: молодые и
старые. И исходит из предположения, что большинство молодых объектов
являются короткоживущими, и для них память нужно чистить чаще. А
большинство старых объектов являются долгоживущими, и для них память
можно чистить реже.

В этом нет ничего особенного, во многих других языках сборка мусора работает аналогично.

А вот что в эрланг особенного, это отдельный сборщик мусора для каждого потока.
В Erlang все сборщики работают независимо друг от друга, в разные моменты времени, и останавливают только свой поток.
И отсюда отсутствие эффекта stop world, когда сборщик мусора должен остановить всю ноду для своей работы.

Если поток короткоживущий (что довольно обычно для Erlang),
то после его завершения вся память потока целиком освобождается, а сборщик мусора даже не успевает поработать.

Если поток долгоживущий, но потребляет мало памяти (типично для супервизора и других потоков, выполняющих "менеджерские" задачи),
то в нем сборщик мусора запускается очень редко, или никогда.

В результате сборка мусора оказывает мало влияния на производительность системы.

Erlang Garbage Collection Details and Why It Matters
https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html


## Интерактивная консоль (Erlang/Elixir Shell)

Как и многие другие языки, эрланг имеет REPL консоль.
Ей удобно пользоваться при разработке.

Но ей можно пользоваться и в продакшен. Можно подключиться к работающей ноде,
вызывать любую функцию любого модуля, отправить сообщение любому потоку,
прочитать и изменить состояние любого потока -- то есть,
взаимодействовать с нодой в реальном времени.

Это очень помогает в диагностике разных проблем и исправлении их налету.


## Трассировка (Tracing)

В эрланг есть встроенный на самом низком уровне механизм трассировки,
мало влияющий на общую производительность системы. Поэтому его можно
использовать на живой, продакшен системе.

Этот механизм позволяет получать в реальном времени информацию:
- жизненный цикл потоков (старт, остановка, связи с другими потоками);
- отправка и получение сообщений;
- вызовы функций, аргументы, возвращаемые значения, откуда вызвана;
- наблюдать состояние памяти потоков, и менять его;
- информацию о работе планировщика;
- информацию о потреблении памяти и работе сборщиков мусора.

Теоретически можно узнать почти все о работе ноды. Практически этой
информации очень много, и сложность в том, чтобы выбрать именно ту, которая важна.

Данные трассировки можно наблюдать в консоли, или перенаправить в
файл, или в свой обработчик. Ее можно получать на той же ноде, или
перенаправить на другую ноду, и обрабатывать и анализировать там.


## Свойства Эликсир

Отдельно рассмотрим свойства Эликсир, которые отличают его от Эрланг, и дают новые возможности.

TODO https://elixir-lang.org/ -- взять отсюда

compilation of features Erlang, Clojure, Ruby

Elixir — функциональный, распределённый язык программирования общего назначения, который работает на виртуальной машине Erlang (BEAM). Построен поверх Erlang, что обеспечивает распределённость, отказоустойчивость, исполнение в режиме мягкого реального времени, метапрограммирование с макросами и полиморфизмом, реализованным через протоколы[3]. Использует Erlang/OTP для работы с деревьями потоков[4]. 

Программы компилируются в байт-код для виртуальной машины Erlang (BEAM)[8]. Каждый элемент программы является выражением[8], функции языка Erlang могут быть вызваны без влияния на время исполнения из-за компиляции байт-кода в Erlang и наоборот.

Метапрограммирование дает возможность прямого манипулирования абстрактным синтаксическим деревом (АСД)[8]. Полиморфизм, реализованный через механизм протоколов, которые, как и в Clojure, обеспечивают механизм диспетчеризации (не стоит путать с множественной диспетчеризацией). Параллельное программирование — без разделения ресурсов, через передачу сообщений (модель акторов)[9]. На практике упор делается на рекурсии и функциях высшего порядка вместо применения циклов, основанных на побочных эффектах. Для реализации простого параллелизма использованы механизмы Erlang с упрощённым синтаксисом (например, Task)[8].

Реализованы ленивые вычисления и асинхронные коллекции с потоками, сопоставление с образцом[8].

Язык поддерживает Unicode и UTF-8-строки. Реализована поддержка документирования кода по синтаксису напоминающая строки документации языка Python, но в формате Markdown[8]. 

Elixir был задуман как улучшение Erlang, в частности, значительного упрощения синтаксиса. Одним из основных отличий является возможность повторного присваивания значений переменных. В Elixir не требуется завершать каждую команду точкой (по примеру Пролога), так как выражения разделяются переводом строки и точкой с запятой (;). В Elixir не требуется экспортировать функции модуля, тогда как в Erlang по умолчанию все функции недоступны из других модулей, если не упомянуты в директиве -export. Тем самым, синтаксис Elixir больше похож на синтаксис Ruby[6]. 

Features

    compiles to bytecode for the Erlang Virtual Machine (BEAM)[28]
    Everything is an expression[28]
    Erlang functions can be called from Elixir without run time impact, due to compilation to Erlang bytecode, and vice versa
    Meta programming allowing direct manipulation of abstract syntax tree (AST)[28]
    Polymorphism via a mechanism called protocols. Like in Clojure, protocols provide a dynamic dispatch mechanism. However, this is not to be confused with multiple dispatch as Elixir protocols dispatch on a single type.
    Support for documentation via Python-like docstrings in the Markdown formatting language[28]
    Shared nothing concurrent programming via message passing (Actor model)[29]
    Emphasis on recursion and higher-order functions instead of side-effect-based looping
    Lightweight concurrency utilizing Erlang's mechanisms[28]
    Railway oriented programming via the with construct
    Built-in tooling for managing dependencies, code compilation, running tests, formatting code, remote debugging and more
    Lazy and async collections with streams
    Pattern matching[28] to promote assertive code[30]
    Unicode support and UTF-8 strings
    
    
К 4 оригинальным свойствам: Fault-tolerance, Scalability, Distribution, Live update,
Sasa Juric добавил еще Responsiveness:
System should always be reasonable fast and responsive. Lengthy tasks should't block the rest of the system
or have a significant effect on performance.
Достигается за счет:
- preemptive schedulers, 
- IO in separate threads, 
- garbage collection per process. 