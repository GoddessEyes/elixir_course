# Иммутабельность

Эликсир, как и для большинство других функциональных языков, основан на иммутабельности данных.

Допустим, мы создали некую структуру данных, сохранили ее в некой области памяти, и присвоили как значение некой переменной. При этом в переменной сохраняется ссылка на эту область памяти. 

Я могу передавать переменную в функцию. Значение передается по ссылке, а не копируется. Но функция не может изменить это значение. Так что передача по ссылке безопасна.

TODO картинка.

Эликсир гарантирует, что выделенная память не модифицируется. Но значение переменной, которая указывает на эту область памяти, можно изменить. То есть, указать на другую область памяти. В Эрланг и этого делать нельзя, не только данные, но и переменные остаются неизменяемыми.  

TODO картинка.

Для примера рассмотрим код:

```
iex(1)> my_list = [1,2,3]
[1, 2, 3]
iex(2)> my_list = my_list ++ [4,5]
[1, 2, 3, 4, 5, 4, 5]
iex(3)> my_list = my_list ++ [6,7,8]
[1, 2, 3, 4, 5, 4, 5, 6, 7, 8]
```

Здесь мы имеем 3 списка, каждый из них размещен в своей области памяти. И здесь есть одна переменная, которая сперва указывает на первый список, затем на второй, затем на третий.

Аналогичный код на Эрланг будет выглядеть так:
```
1> MyList = [1,2,3].
[1,2,3]
2> MyList2 = MyList ++ [4,5].
[1,2,3,4,5]
3> MyList3 = MyList2 ++ [6,7,8].
[1,2,3,4,5,6,7,8]
```
Здесь тоже 3 списка, и 3 разные переменные, которые указывают каждая на свой список.

На самом деле код на Эликсире является синтаксическим сахаром. При компиляции он превращается в такой же код, как на Эрланге. 

Благодаря иммутабельности:
- устраняется определенный класс ошибок;
- упрощается отладка;
- компилятор имеет больше возможностей для оптимизации кода;
- статический анализатор имеет больше возможностей для проверки корректности кода.

Плата за это -- несколько менее эффективные структуры данных, чем в императивных языках.


## Structure Sharing

Любые данные нужно как-то модифицировать, иммутабельные данные не исключение. Если каждый раз при модификации мы будем создавать полную копию данных, то это будет очень не эффективно и по использованию памяти, и по использованию CPU. Поэтому полного копирования не происходит.

В примере выше, 3 списка совмесно используют одну и ту же область памяти. А новая память выделяется только под новые элементы. Аналогично работает и Map.

```
iex(1)> my_map = %{a: 42} 
%{a: 42}
iex(2)> other_map = Map.put(my_map, :b, 500)
%{a: 42, b: 500}
iex(3)> yet_another_map = Map.put(my_map, :c, 100500)
%{a: 42, c: 100500}
iex(4)> my_map
%{a: 42}
iex(5)> other_map
%{a: 42, b: 500}
iex(6)> yet_another_map
%{a: 42, c: 100500}
```

TODO картинка