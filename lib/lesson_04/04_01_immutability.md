# Иммутабельность

Эликсир, как и для большинство других функциональных языков, основан на иммутабельности данных.

Польза иммутабельности:
- исключает ошибоки, связанные с модификацией одной области памяти из разных мест в коде;
- в тч из разных потоков, что существенно упрощает многопоточное программирование;  
- упрощает сборку мусора (связи между данными представлены ацикличным графом);
- сохраняются все промежуточные версии данных, что упрощает отладку;
- компилятор имеет больше возможностей для оптимизации кода;
- статический анализатор имеет больше возможностей для проверки корректности кода.

Плата за это -- несколько менее эффективные структуры данных, чем в императивных языках. Можно говорить, что в среднем производительность мутабельных и иммутабельных структур данных сопоставимая, но в крайних случаях производительность хуже, иногда существенно хуже.

К счастью, под капотом в VM многие операции реализованы на мутабельных данных.


## Как это работает

Допустим, мы создали некую структуру данных, сохранили ее в некой области памяти, и присвоили как значение некой переменной. При этом в переменной сохраняется ссылка на эту область памяти. 

Я могу передавать переменную в функцию. Значение передается по ссылке, а не копируется. Но функция не может изменить это значение. Так что передача по ссылке безопасна.

TODO картинка.

Эликсир гарантирует, что выделенная память не модифицируется. Но значение переменной, которая указывает на эту область памяти, можно изменить. То есть, указать на другую область памяти. В Эрланг и этого делать нельзя, не только данные, но и переменные остаются неизменяемыми.  

TODO картинка.

Для примера рассмотрим код:

```
iex(1)> my_list = [1,2,3]
[1, 2, 3]
iex(2)> my_list = my_list ++ [4,5]
[1, 2, 3, 4, 5, 4, 5]
iex(3)> my_list = my_list ++ [6,7,8]
[1, 2, 3, 4, 5, 4, 5, 6, 7, 8]
```

Здесь мы имеем 3 списка, каждый из них размещен в своей области памяти. И здесь есть одна переменная, которая сперва указывает на первый список, затем на второй, затем на третий.

Аналогичный код на Эрланг будет выглядеть так:
```
1> MyList = [1,2,3].
[1,2,3]
2> MyList2 = MyList ++ [4,5].
[1,2,3,4,5]
3> MyList3 = MyList2 ++ [6,7,8].
[1,2,3,4,5,6,7,8]
```
Здесь тоже 3 списка, и 3 разные переменные, которые указывают каждая на свой список.

На самом деле код на Эликсире является синтаксическим сахаром. При компиляции он превращается в такой же код, как на Эрланге. 


## Переиспользование памяти (Structure Sharing)

Любые данные нужно как-то модифицировать, иммутабельные данные не исключение. Если каждый раз при модификации мы будем создавать полную копию данных, то это будет очень не эффективно и по использованию памяти, и по использованию CPU. 

Поэтому полного копирования не происходит. Вместо этого, при создании новой структуры данных BEAM переиспользует часть или всю старую структура. Иммутабельность позволяет это делать.

TODO: У Саши Журича взять картинки, как работает structure sharing для tuple и list.
page 38.

В примере выше, 3 списка совмесно используют одну и ту же область памяти. А новая память выделяется только под новые элементы. Аналогично работает и Map.

```
iex(1)> my_map = %{a: 42} 
%{a: 42}
iex(2)> other_map = Map.put(my_map, :b, 500)
%{a: 42, b: 500}
iex(3)> yet_another_map = Map.put(my_map, :c, 100500)
%{a: 42, c: 100500}
iex(4)> my_map
%{a: 42}
iex(5)> other_map
%{a: 42, b: 500}
iex(6)> yet_another_map
%{a: 42, c: 100500}
```