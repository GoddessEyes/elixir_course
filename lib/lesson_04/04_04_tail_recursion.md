# Хвостовая рекурсия

Надо понимать, что рекурсия -- штука не бесплатная. Каждый рекурсивный вызов требует сохранения на стеке предыдущего состояния функции, чтобы вернуться в него после очередного вызова.

И хотя стек в BEAM легковесный и позволяет делать миллионы рекурсивных вызовов, (а не тысячи, как в большинстве мейнстримовых языков), он, все-таки, конечный.

Поэтому в Эликсир, как и во многих других функциональных языках, компилятор делает одну полезную штуку, которая называется **оптимизация хвостовой рекурсии**.

Если рекурсивный вызов является последней строчкой кода в данной функции, и после него больше никаких инструкций нет, то такой вызов называется хвостовым. В этом случае нет необходимости возвращаться по стеку во все вызывающие
функции, а можно сразу отдать результат из последнего вызова. И стек не растет, а используется заново каждым новым вызовом, и адрес возврата в нем не меняется.

Это позволяет делать бесконечную рекурсию, которая нужна для бесконечно живущих процессов.  А такие процессы нужны серверам :)

Значит ли это, что всегда нужно всегда использовать хвостовую рекурсию? Нет. 

Код без хвостовой рекурсии часто получается короче и проще, а иногда и лучше по производительности. Если нам нужна бесконечная, или очень долгая рекурсия (миллионы итераций), то без хвостовой рекурсии не обойтись. Но если мы уверены, что у нас будет конечное и не очень большое число итераций, то можно выбрать вариант без неё.


## Пример

Давайте рассмотрим две реализации факториала.

```
iex(1)> c "lib/lesson_04/task_04_04_tail_recursion.exs"
[Lesson_04.Task_04_04_TailRecursion] 
iex(2)> alias Lesson_04.Task_04_04_TailRecursion, as: TTR
Lesson_04.Task_04_04_TailRecursion
iex(3)> TTR.factorial(10)
3628800
iex(4)> TTR.factorial_t(10)
3628800
iex(5)>
```

Первая реализация без хвостовой рекурсии, и код у нее очень простой. Вторая реализация использует специальный подход "рекурсия с аккумулятором", что позволяет получить хвостовую рекурсию за счет того, что промежуточные результаты сохраняются не на стеке, а в специальном аргументе функции, который называется "аккумулятор".

Мы подробнее рассмотрим рекурсию с аккумулятором в следущей теме. А сейчас сравним обе реализации по тому, как они расходуют память.


## Расход памяти

В книге Learn Functional Programming with Elixir by Ulisses Almeida описываются две реализации факториала, с хвостовой рекурсией и без нее. И они сравниваются по потреблению памяти, по данным System Monitor для процесса beam.smp. 

У автора получилось, что в реализации без хвостовой рекурсии процесс beam.smp при вычислении факториала 10_000_000 потреблял 756Mb памяти. А с хвостовой рекурсией -- 56Mb. Разница впечатляющая. 

Я попробовал воспроизвести эти результаты. У меня OTP 23.2 (у автора версия не указана). Получилось так:

Без хвостовой рекурсии:
factorial(20_000) - 96Mb
factorial(40_000) - 113Mb
factorial(100_000) - 1.5G,
factorial(200_000) - 2.5G, не вычислил, beam убит, вероятно ООМ киллером. (У меня на ноуте 16Gb памяти, но свободной было 3Gb). 

С хвостовой рекурсией:
factorial(20_000) - 96Mb
factorial(40_000) - 200Mb
factorial(100_000) - 1.3G

Гм, ну даже не знаю, что и сказать. На практике не так все просто :)

Тогда я посмотрел 
:erlang.process_info(self(), :memory)
:erlang.memory()
для обоих случаев, с вызовом 
:erlang.garbage_collect
перед вызовом факториала для 40_000.

Получилось, что без хвостовой рекурсии :erlang.process_info показывает рост c 34Kb до 102Mb, а :erlang.memory показывает рост total memory с 27Mb до 131Mb за счет processes. 

С хвостовой рекурсией, соответственно, рост с 142Kb до 426Kb, и падение с 28Mb до 25Mb. 

То есть, инфа по одному процессу соответствует теории, да еще и разница на 2 порядка. А вот инфа по beam в целом не показывает ничего убедительного. 



```
iex(3)> :erlang.garbage_collect
true
iex(4)> :erlang.process_info(self(), :memory)
{:memory, 34460}
iex(5)> :erlang.memory()
[
  total: 27308496,
  processes: 7302848,
  processes_used: 7301904,
  system: 20005648,
  atom: 499905,
  atom_used: 499045,
  binary: 407592,
  code: 10004519,
  ets: 521328
]

TTR.factorial(40_000)

iex(8)> :erlang.process_info(self(), :memory)
{:memory, 102764108}
iex(9)> :erlang.memory()                     
[
  total: 131033320,
  processes: 110025760,
  processes_used: 110024696, 
  system: 21007560,
  atom: 499905,
  atom_used: 499045,
  binary: 738392,
  code: 10004519,
  ets: 521328
]

iex(10)> :erlang.garbage_collect              
true
iex(11)> :erlang.process_info(self(), :memory)
{:memory, 142924}
iex(12)> :erlang.memory()                     
[
  total: 28255280,
  processes: 7412352,
  processes_used: 7411408,
  system: 20842928,
  atom: 499905,
  atom_used: 499045,
  binary: 573632,
  code: 10004519,
  ets: 521328
]

TTR.factorial_t(40_000)

iex(14)> :erlang.process_info(self(), :memory)
{:memory, 426628}
iex(15)> :erlang.memory()                     
[
  total: 25937048,
  processes: 5167248,
  processes_used: 5166184,
  system: 20769800,
  atom: 499905,
  atom_used: 499045,
  binary: 500496,
  code: 10004519,
  ets: 521328

```




