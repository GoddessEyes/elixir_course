## Устройство списков

Списки, как и любые другие структуры данных, являются неизменяемыми.

Вот мы создаем список и присваиваем его переменной List:

```
List = [1, 2, 3, 4].
```

В памяти у нас появляется вот такая структура:

![Linked list im memory](http://yzh44yzh.github.io/img/practical_erlang/list_1.png)

4 элемента списка сохраняются в виде пар ссылка + значение, где ссылка
указывает на предыдущий элемент.  В последнем элементе ссылка нулевая,
никуда не указывает.

Как же нам добавить новый элемент? Этот список мы модифицировать не
можем, но можем создать новый список, включающий один новый элемент и
все элементы старого списка:

```
List2 = [0 | List].
```

Оператор **|** называется **cons**, он добавляет новый элемент к
голове списка и возвращает новый список.

![List concatenation](http://yzh44yzh.github.io/img/practical_erlang/list_2.png)

В новом элементе ссылка указывает на первый элемент списка **List**. В самом списке List
ничего не меняется. Область памяти, которую он занимает, модифицировать не нужно.

Итого, у нас теперь есть два списка. Но при этом расход памяти минимальный, ибо
большая ее часть используется обоими списками.

Любой список можно представить как последовательность операторов cons:

```
[0 | [1 | [2 | [3 | [4 | []]]]]]
```

Или схематически:

![List as set of concatenations](http://yzh44yzh.github.io/img/practical_erlang/list_3.png)

Оператор cons используется и для добавления элемента в начало списка,
и для разделения списка на начальный элемент (голова) и все остальные
элементы (хвост).

```
[Head | Tail] = List.
```

А что было бы, если бы мы использовали двунаправленный связанный список?
Он представлен в памяти так:

![Doubly linked list](http://yzh44yzh.github.io/img/practical_erlang/list_4.png)

Каждый элемент состоит из значения и двух ссылок. Одна ссылка указывает на предыдущий элемент,
другая ссылка на следующий элемент.

И попробуем добавить к такому списку новое значение.

![Add element to doubly linked list](http://yzh44yzh.github.io/img/practical_erlang/list_5.png)

Ссылка в новом элементе указывает на голову списка. Но еще нужно в голове списка поменять ссылку,
чтобы она указывала на новый элемент. Поменять ссылку -- это значит, модифицировать память,
нарушить ссылочную прозрачность.

Ок, мы можем не модифицировать ссылку в элементе, а скопировать весь элемент:

![Copy element of doubly linked list](http://yzh44yzh.github.io/img/practical_erlang/list_6.png)

Но теперь нужно менять ссылку в предыдущем элементе. А значит, нужно копировать и его тоже.
И таким образом мы скопируем весь список целиком.

Двунаправленные связанные списки делают невозможным использование одного участка памяти
несколькими списками. Для каждого придется выделять отдельный участок памяти. А если учесть,
что добавление одного элемента, это создание нового списка, то расход памяти будет очень большим.


## Стоимость операций для списков

 - добавить элемент в начало списка - O(1);
 - добавить элемент в конец списка - O(n) и полное копирование памяти;
 - определить длину списка - O(n);
 - получить N-й элемент - O(n).

Еще рассмотрим суммирование двух списков:

```
List1 ++ List2.
```

Стоимость этой операции O(n), где n длина первого списка.
Память первого списка копируется, память второго списка используется повторно.

Тут важно, чтобы List1 был коротким, а длина List2 не важна.
Часто мы не знаем длинны List1 и поэтому операцию сложения списков считаем дорогой.
На одном из последующих уроков мы узнаем, как избегать этой операции
с помощью **iolist**.


Для сравнения, стоимость операций для массивов в императивных языках:

 - добавить элемент в начало массива - O(n), ибо все остальные элементы нужно сдвигать;
 - добавить элемент в конец массива - O(1), если мы укладываемся в размер массива,
   O(n) если массив нужно увеличивать;
 - определить длину массива - O(1);
 - получить/модифицировать N-й элемент - O(1).

Самое главное преимущество массивов над списками -- константное время доступа к любому элементу.
Цена за это: потеря ссылочной прозрачности.

В эрланг есть модуль **array**, реализующий массивы. Но разработчики его не используют,
ибо этот модуль не дает константного времени доступа к любому элементу, и, значит,
не имеет никаких преимуществ над списками.