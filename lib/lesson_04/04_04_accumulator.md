## Рекурсивные функции с аккумуляторами

Типичный способ работы со списками -- использование рекурсивных функций и аккумуляторов.
Рассмотрим эту тему на конкретных примерах.


## Пример 1

Допустим, у нас есть список пользователей:

```
iex(1)> c "lib/lesson_04/task_04_04_accumulator.exs"
[Lesson_04.Task_04_04_Accumulator, Task_04_Test]
iex(2)> alias Lesson_04.Task_04_04_Accumulator, as: TA
Lesson_04.Task_04_04_Accumulator
iex(3)> TA.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
```

И мы хотим отфильтровать совершеннолетних пользователей. То есть, получить новый список, где будут только пользователи старше 16 лет.

Применим рекурсивную функцию с аккумулятором:

```
iex(6)> users = TA.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
iex(7)> TA.filter_adults(users)
[{:user, 2, "Helen", 20}, {:user, 1, "Bob", 23}]
```

Функция получает на вход два аргумента: список пользователей, и
список, где будет накапливаться результат выполнения -- аккумулятор. В
начале выполнения список пользователей полный, а аккумулятор
пустой. На каждом шаге итерации мы будем брать один элемент из первого
списка, и, если он нам нужен, то класть его в аккумулятор. В итоге первый
список опустошится, а аккумулятор наполнится.

Наша рекурсивная функция имеет два тела (clause). В зависимости от
входящих аргументов выполняется либо одно тело, либо другое. Тут
действует сопоставление с образцом (pattern matching), который мы
будем рассматривать позже. Сейчас мы просто знаем, что первое тело
выполняется, когда список пользователей пустой. То есть, это
завершение фильтрации. И тут нужно просто отдать накопленный
результат.

Второе тело и делает всю работу. Сперва список пользователей с помощью
оператора cons делится на голову и хвост (это можно делать
прямо в описании аргументов функции).  Голова -- это текущий элемент
списка, который мы будем анализировать. Хвост -- это остаток списка,
который мы передадим дальше, в следующий рекурсивный вызов.

Анализ элемента тут простой: определяем возраст пользователя. Пользователей младше 16 лет мы игнорируем, а старше добавляем в аккумулятор, опять с помощью оператора cons.

Элементы в аккумуляторе накапливаются в обратном порядке. Если это не
важно, то аккумулятор можно вернуть, как есть. Если желательно
сохранить оригинальный порядок, то аккумулятор нужно развернуть.


## Пример 2

Второй пример. Допустим, из списка пользователей нужно извлечь их идентификаторы и имена.
То есть, получить список кортежей вида:

```
{id, name}
```

Делаем:

```
iex(11)> TA.get_id_name(users)
[{1, "Bob"}, {2, "Helen"}, {3, "Bill"}, {4, "Kate"}]
```

Опять два тела у функции. Первое тело отвечает за завершение рекурсии и возврат результата,
накопленного в аккумуляторе.

Второе тело обрабатывает каждый элемент списка, извлекает из кортежа 
```
{:user, id, name, age}
```
нужные id и name, и сохраняет их в аккумуляторе.

Хорошая практика -- предлагать как публичный АПИ функцию с одним аргументом. А функцию
с аккумулятором скрывать от пользователей модуля. Потому что аккумулятор может быть сложнее,
чем просто список, и пользователям модуля незачем об этом знать.


## Пример 3

И вот пример со сложным аккумулятором. Допустим нам нужно разделить пользователей на два списка: несовершеннолетние и взрослые.

```
iex(16)> TA.split_teens_and_adults(users)
{[{:user, 3, "Bill", 15}, {:user, 4, "Kate", 14}],
 [{:user, 1, "Bob", 23}, {:user, 2, "Helen", 20}]}

```

На сей раз наш аккумулятор -- это кортеж из двух списков. В первом теле функции, как обычно,
возвращаем результат. И тут мы разворачиваем оба списка. Во втором теле функции обрабатываем
каждый элемент списка, извлекаем и проверяем возраст. Тех, кто моложе 16 лет, кладем в первый
список в аккумуляторе, остальных во второй список.
