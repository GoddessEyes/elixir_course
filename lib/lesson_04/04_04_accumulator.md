## Рекурсивные функции с аккумуляторами

TODO
https://github.com/yzh44yzh/practical_erlang/blob/master/02_list_recursion/list_samples.erl
https://github.com/yzh44yzh/practical_erlang/blob/master/02_list_recursion/main.erl

Типичный способ работы со списками -- использование рекурсивных функций и аккумуляторов.
Рассмотрим эту тему на конкретных примерах.

Допустим, у нас есть список пользователей:

```
Users = [{user, 1, "Bob", male},
         {user, 2, "Helen", female},
         {user, 3, "Bill", male},
         {user, 4, "Kate", female}].
```

И мы хотим отфильтровать пользователей женского пола. То есть, получить новый список,
где будут только девушки.

Применим рекурсивную функцию с аккумулятором:

```
filter_female([], Acc) -> Acc;
filter_female([User | Rest], Acc) ->
    case User of
        {user, _, _, male} -> filter_female(Rest, Acc);
        {user, _, _, female} -> filter_female(Rest, [User | Acc])
    end.
```

Функция получает на вход два аргумента: список пользователей, и
список, где будет накапливаться результат выполнения -- аккумулятор. В
начале выполнения список пользователей полный, а аккумулятор
пустой. На каждом шаге итерации мы будем брать один элемент из первого
списка, и, если он нам нужен, то класть его в аккумулятор. В итоге первый
список опустошится, а аккумулятор наполнится.

Наша рекурсивная функция имеет два тела (clause). В зависимости от
входящих аргументов выполняется либо одно тело, либо другое. Тут
действует сопоставление с образцом (pattern matching), который мы
будем рассматривать позже. Сейчас мы просто знаем, что первое тело
выполняется, когда список пользователей пустой. То есть, это
завершение фильтрации. И тут нужно просто отдать накопленный
результат.

Второе тело и делает всю работу. Сперва список пользователей с помощью
оператора cons делится на голову и хвост (это можно делать
прямо в описании аргументов функции).  Голова -- это текущий элемент
списка, который мы будем анализировать. Хвост -- это остаток списка,
который мы передадим дальше, в следующий рекурсивный вызов.

Анализ элемента тут простой: с помощью конструкции case и
сопоставления с образцом определяем пол пользователя. Пользователей
мужского пола мы игнорируем, а женский пол добавляем в аккумулятор,
опять с помощью оператора cons.

case и сопоставление с образцом пока что не изучены, но вы ведь уже
прочитали об этом в рекомендованных книгах, правда?  Если нет, то
самое время прочитать :) Увы, в практических упражнениях приходится
немного забегать вперед, ибо без этих конструкций мало чего полезного
можно сделать :)

Элементы в аккумуляторе накапливаются в обратном порядке. Если это не
важно, то аккумулятор можно вернуть, как есть. Если желательно
сохранить оригинальный порядок, то аккумулятор нужно развернуть:

```
filter_female([], Acc) -> lists:reverse(Acc);
```

Второй пример. Допустим, из списка пользователей нужно извлечь их идентификаторы и имена.
То есть, получить список кортежей вида:

```
{Id, Name}
```

Делаем:

```
get_names([], Acc) -> lists:reverse(Acc);
get_names([User | Rest], Acc) ->
    {user, Id, Name, _} = User,
    get_names(Rest, [{Id, Name} | Acc]).
```

Опять два тела у функции. Первое тело отвечает за завершение рекурсии и возврат результата,
накопленного в аккумуляторе.

Второе тело обрабатывает каждый элемент списка, извлекает из кортежа {user, Id, Name, Gender}
нужные данные Id и Name, и сохраняет их в аккумуляторе.

Хорошая практика -- предлагать как публичный АПИ функцию с одним аргументом. А функцию
с аккумулятором скрывать от пользователей модуля. Потому что аккумулятор может быть сложнее,
чем просто список, и пользователям модуля незачем об этом знать.

```
get_names(Users) -> get_names(Users, []).

get_names([], Acc) -> lists:reverse(Acc);
get_names([User | Rest], Acc) ->
    {user, Id, Name, _} = User,
    get_names(Rest, [{Id, Name} | Acc]).
```

И вот пример со сложным аккумулятором. Допустим нам нужно разделить пользователей на два списка.
В первом те, кому меньше 18 лет, во втором от 18 и старше. Тут, конечно, будет немного другой
список пользователей, с указанием возраста:

```
Users = [{user, 1, "Bob", male, 27},
         {user, 2, "Helen", female, 18},
         {user, 3, "Bill", male, 15},
         {user, 4, "Kate", female, 11}].
```

Реализация:

```
partition_users(Users) -> partition_users(Users, {[], []}).

partition_users([], {List1, List2}) -> {lists:reverse(List1), lists:reverse(List2)};
partition_users([User | Rest], {List1, List2}) ->
    {user, _, _, _, Age} = User,
    if
        Age < 18 -> partition_users(Rest, {[User | List1], List2});
        true -> partition_users(Rest, {List1, [User | List2]})
    end.
```

На сей раз наш аккумулятор -- это кортеж из двух списков. В первом теле функции, как обычно,
возвращаем результат. И тут мы разворачиваем оба списка. Во втором теле функции обрабатываем
каждый элемент списка, извлекаем и проверяем возраст. Тех, кто моложе 18 лет, кладем в первый
список в аккумуляторе, остальных во второй список.
