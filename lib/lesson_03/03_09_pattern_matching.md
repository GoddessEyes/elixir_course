# Сопоставление с образцом (Pattern Matching)

Одна из главных особенностей функционального программирования -- сопоставление с образцом. Применяется очень широко, так что вряд ли можно найти такую программу на функциональном языке, где нет pattern matching.

Сопоставление с образцом используется для:
- присвоения значений переменным;
- извлечения значений из сложных структур данных;
- условных переходов.

Рассмотрим все эти случаи на примерах.


## Присвоение значений переменным

```
iex(1)> a = 123
123
iex(2)> a
123
```

Эта элементарная конструкция, которая выглядит как присваивание значения переменной, на самом деле не является присваиванием. Присваивания в Эликсире нет, а оператор **=** называеся оператор сопоставления (match operator).

В данном коде значение справа -- **123**, сопоставляется с шаблоном слева -- переменной **a**. И поскольку шаблон соответствует значению, то сопоставление происходит успешно, и переменная **а** связывается со значением.

Однако, это тривиальный случай. Чтобы понять PM нужно рассмотреть более сложные случаи.


## Извлечение значений из сложных структур данных

```
iex(3)> user = {:user, "Bob", 25}
{:user, "Bob", 25}
iex(4)> {:user, name, age} = user
{:user, "Bob", 25}
iex(5)> name
"Bob"
iex(6)> age
25
```

Первая строка опять выглядит как присваивание. Только значение более сложноее -- кортеж их трех элементов. А вот вторая строка уже интереснее. 

Слева от оператора **=** шаблон, который ограничивает множество значений. Этот шаблон может совпасть только с такими значениями, которые являются кортежами из трех элементов, первым элементом обязательно должен быть атом **:user**, а второй и третий элемент могут быть любыми. 

Справа от оператора **=** находится значение, которое мы сравниваем с шаблоном. В данном случае значение извлекается из переменной **user**, но оно может быть и результатом вызова функции или литералом.

Сопоставление проходит успешно, и в результате переменные шаблона **name** и **age** получают значения **"Bob"** и **25**.

В случае, если значение не совпадает с шаблоном, возникает исключение:
```
iex(7)> {:user, name, age} = {:dog, "Sharik", 5}
** (MatchError) no match of right hand side value: {:dog, "Sharik", 5}

iex(7)> {:user, name, age} = {:user, "Bob", 25, :developer}
** (MatchError) no match of right hand side value: {:user, "Bob", 25, :developer}
```

Первое значение не совпало, потому что :dog != :user. Второе значение не совпало, потому что в кортеже 4 элемента, а не 3.

И значение, и шаблон могут быть сложными структурами с любой глубиной вложенности:
```

users = [
{:user, "Bob", :developer, {:lang, ["Erlang", "Elixir"]}},
{:user, "Bill", :developer, {:lang, ["Python", "JavaScript"]}}
]

[{:user, _, _, _}, {:user, name, _, {:lang, [lang1, lang2]}}] = users
[
  {:user, "Bob", :developer, {:lang, ["Erlang", "Elixir"]}},
  {:user, "Bill", :developer, {:lang, ["Python", "JavaScript"]}}
]
iex(14)> name
"Bill"
iex(15)> lang1
"Python"
iex(16)> lang2
"JavaScript"
```

Здесь у нас список из двух элементов. Каждый элемент является кортежем из 4х элементов. 4-й элемент кортежа, это вложенный кортеж. И в нем еще один вложенный список. Наш шаблон повторяет всю эту структуру и извлекает значения из 4-го уровня вложенности.

Обратите внимания на символ подчеркивания. Он совпадает с любым значением, и применяется, когда это значение не нужно, мы не хотим сохранять его в переменную.

Если переменная встречается два раза, то значения в этих местах должны быть одинаковыми: 
```
iex(20)> {a, a, 42} = {10, 10, 42}
{10, 10, 42}
iex(21)> {a, a, 42} = {20, 20, 42}
{20, 20, 42}
iex(22)> {a, a, 42} = {10, 20, 42}
** (MatchError) no match of right hand side value: {10, 20, 42}
```

Но это не касается символа подчеркивания:
```
iex(22)> {_, _, 42} = {10, 10, 42}
{10, 10, 42}
iex(23)> {_, _, 42} = {20, 20, 42}
{20, 20, 42}
iex(24)> {_, _, 42} = {10, 20, 42}
{10, 20, 42}
```


## Как устроен Pattern Matching

TODO stopped here

[pattern] = [value]
Слева:
литералы
несвязанные переменные
связанные переменные (pin operator)

Справа:
литералы
связанные переменные

numbers in patterns perform strict comparison. In other words, integers to do not match floats.

Note that the empty map will match all maps, which is a contrast to tuples and lists, where an empty tuple or an empty list will only match empty tuples and empty lists respectively.

pin operator
Prefix variable with ^ (a caret)
```
iex> a = 1
1
iex> [^a, 2, 3 ] = [ 1, 2, 3 ]
# use existing value of a
[1, 2, 3]
```

Joe Armstrong, Erlang’s creator, compares the equals sign in Erlang to that used in algebra. 
When you write the equation x = a + 1, you are not assigning the value of a + 1 to x. 
Instead you’re simply asserting that the expressions x and a + 1 have the same value. 
If you know the value of x, you can work out the value of a, and vice versa.
His point is that you had to unlearn the algebraic meaning of = 
when you first came across assignment in imperative programming languages. 
Now’s the time to un-unlearn it.
_это хорошо, это надо взять_


## Условные переходы

Сопоставление с образцом также используется для ветвлений в коде (условных переходов):
- конструкция case
- function clause
- обработка исключений (resque, catch)
- чтение сообщений из mailbox (receive) 

```
6> case User of
6> {user, _, _} -> "this is user";
6> {cat, _, _} -> "this is cat"
6> end.
"this is user"
```


Ниже мы рассмотрим все эти варианты. А сейчас один пример из реального
проекта. Это игра, где несколько пользователей собираются за одним
столом. Один из игроков является владельцем комнаты.  Данная функция
позволяет определить, является ли данный игрок владельцем данной
комнаты:

```
is_user_owner_of_room(UserId, RoomId) ->
    case rooms:find_room(RoomId) of
        {ok, #room{owner = UserId}} -> true;
        _ -> false
    end.
```

Здесь **rooms:find_room/1** может вернуть либо **{ok, #room{}}**, либо
**{error, not_found}**. В первом шаблоне конструкции **case** мы
проверяем, что find_room вернула **{ok, #room{}}**, причем owner
совпадает с UserId.

Таким образом, мы одним шаблоном проверяем сразу два условия:

 - что комната с таким RoomId существует;
 - что владелец у нее именно UserId, а не кто-то другой.

В императивном языке тут было бы две конструкции **if**.
