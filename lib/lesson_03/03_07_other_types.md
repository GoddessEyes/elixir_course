### Другие типы 

ref, pid, port, 

Эти типы являются идентификаторами.

pid является идентификатором потока, зная который, можно отправлять потоку сообщения.

1> F = fun() -> timer:sleep(5000) end.
#Fun<erl_eval.20.90072148>
2> Pid = spawn(F).
<0.36.0>
3> Pid ! hello.
hello

port является идентификатором специального процесса, связанного с сокетом.

1> gen_tcp:listen(8080, []).
{ok,#Port<0.588>}
2> gen_udp:open(9090).
{ok,#Port<0.593>}

reference является идентификатором общего назначения, который можно использовать по своему усмотрению. Например, как ключ для хранения объекта в ets таблице. Или им можно пометить сообщение, отправленное другому потоку, и ждать ответное сообщение, помеченное тем же ключом.

1> Ref = make_ref().
#Ref<0.0.0.30>
2> Pid = spawn(timer, sleep, [10000]).
<0.36.0>
3> Pid ! {Ref, hello}.
{#Ref<0.0.0.30>,hello}

Эрланг гарантирует, что make_ref при каждом вызове генерирует новый уникальный ключ.


### function

Конечно, функциональный язык не может обойтись без анонимных функций, они же лямбды, они же замыкания. Для них тоже есть отдельный тип данных. Эти функции можно сохранять в переменную, передавать как аргументы в другие функции, и даже посылать на другую ноду, чтобы выполнить там.

1> F = fun(Val) -> Val rem 2 =:= 0 end.
#Fun<erl_eval.6.90072148>
2> lists:filter(F, [1,2,3,4,5,6]).
[2,4,6]


Простые и составные типы данных. Условность этого разделения (pid простой или составной?)

