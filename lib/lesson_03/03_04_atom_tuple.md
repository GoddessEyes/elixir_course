### Atom, Tuple

Атомы типичны для функциональных языков, но не встречаются в языках императивных.

Это некие константные значения, которые можно сравнивать друг с другом на предмет совпадения. Собственно, сравнивать -- это единственное, что с ними можно делать.

Atoms are efficient both memory- and performance-wise.
Less memory than the same string.
Quicker comparison operation than the same string.
best used for named constants

При этом они очень широко используются. Но не так, как в примере выше, а в основном для "сопоставления с образцом" (pattern matching). 

Пока можно считать, что это некий аналог перечислений (enum), хотя это не совсем точно.

Кортеж -- структура данных, объединяющая несколько разных значений в одно. Похож на список, но в отличие от списка имеет фиксированную длину.
memory efficient

A typical Elixir tuple has two to four elements —
any more and you’ll probably want to look at Map or Struct.

Это еще одна сущность, которая есть во всех функциональных языках, но редко встречается в императивных. Главная польза от кортежей идет в комплекте с сопоставлением с образцом. Поэтому мы будем изучать их вместе.

Типичный учебный пример: кортеж из двух чисел, задающий координаты точки на плоскости. Или кортеж из трех чисел, задающий координаты точки в пространстве.

Для эрланга характерно на первое место в кортеже ставить атом, поясняющий, какое значение в нем хранится.
{point, 5.2, 4.6}.

Такие кортежи называются тэгированными (tagged tuple). Это отчасти компенсирует анонимность значений.

Ну и кортежи могут быть вложены друг в друга на несколько уровней.
 {rect, {point, 10, 10}, {point, 20, 20}}.
 
Обычно кортежи бывают небольшими -- 2-5 элементов. Для небольших кортежей смысл вложенных в них значений понятен из контекста. Если нужно хранить больше элементов, тогда лучше использовать другие структуры данных -- struct или map. О них пойдет речь ниже.
 
пересекаются ли два прямоугольника (что-то в этом роде)

реализовать функцию distance/2, которая вычисляет расстояние между двумя точками

distance({X1, Y1}, {X2, Y2}) ->
    W = abs(X1 - X2),
    H = abs(Y1 - Y2),
    math:sqrt(W * W + H * H).


distance_test() ->
    ?assertEqual(5.0, distance({0, 0}, {0, 5})),
    ?assertEqual(5.0, distance({5, 0}, {0, 0})),
    ?assertEqual(0.0, distance({5, 5}, {5, 5})),
    ?assertEqual(5.0, distance({0, 0}, {3, 4})),
    ?assertEqual(5.0, distance({0, 0}, {-3, -4})),
    ?assertEqual(12.806248474865697, distance({2, 2}, {10, 12})),
    ?assertEqual(21.213203435596427, distance({-5, -5}, {10, 10})),
    ?assertEqual(21.400934559032695, distance({-5, 5}, {8, -12})),
    ?assertEqual(17.26267650163207, distance({-5, 5}, {-8, -12})),
    ok.
    