# Функции высшего порядка

Функции во всех функциональных языках являются обычными значениями. Их можно сохранять в переменную, передавать в аргументах, возвращать из функции.

Функции высшего порядка (higher-order functions, HOF) -- это функции, которые принимают в аргументах другие функции, или возвращают другие функции.

В стандартном модуле **Enum** таких функций много. И самые важные из них, это **map**, **filter** и **reduce**. В других ФП языках (например, в Эрланг) reduce часто называют **fold**. Эти три функции составляют основу применения HOF, потому что все остальное строится на их базе. 

Сами эти функции реализованы как рекурсия с аккумулятором, и их не сложно реализовать самому.

Порядок аргументов таков, чтобы функции было удобно использовать с оператором pipe. Поэтому список (или другая коллекция) всегда идет первым аргументом. 


## Map

**map** применяет переданную функцию к каждому элементу списка и возвращает новый список.

```
iex(1)> lst = [1,2,3,4,5]
[1, 2, 3, 4, 5]
iex(2)> f = fn i -> i * i end
#Function<44.97283095/1 in :erl_eval.expr/5>
iex(3)> Enum.map(lst, f) 
[1, 4, 9, 16, 25]
```

```
$ iex lib/lesson_05/task_05_01_hof.exs
iex(1)> alias Lesson_05.Task_05_01_HOF, as: HOF 
Lesson_05.Task_05_01_HOF
iex(2)> lst = HOF.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
iex(3)> f = fn({:user, id, name, age}) -> {:user, id, String.upcase(name), age} end
#Function<44.97283095/1 in :erl_eval.expr/5>
iex(4)> Enum.map(lst, f)
[
  {:user, 1, "BOB", 23},
  {:user, 2, "HELEN", 20},
  {:user, 3, "BILL", 15},
  {:user, 4, "KATE", 14}

```

## Filter

**filter** использует переданную функцию как предикат для фильтрации списка.

```
iex(5)> f = fn(i) -> i > 3 end
#Function<44.97283095/1 in :erl_eval.expr/5>
iex(6)> Enum.filter([1,2,3,4,5], f)
[4, 5]
```

```
iex(9)> users = HOF.test_data                                
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
iex(10)> f = fn({:user, id, _, _}) -> rem(id, 2) == 0 end     
#Function<44.97283095/1 in :erl_eval.expr/5>
iex(11)> Enum.filter(users, f)                           
[{:user, 2, "Helen", 20}, {:user, 4, "Kate", 14}]
```

Мы можем взять примеры из прошлого урока, и переписать их с использованием map и filter.

TODO stopped here

Фильтрация пользователей по полу:

```
get_females(Users) ->
    F = fun({user, _, _, male, _}) -> false;
           ({user, _, _, female, _}) -> true
        end,
    lists:filter(F, Users).
```

Получение id и name пользователя:

```
get_id_name(Users) ->
    F = fun({user, Id, Name, _, _}) -> {Id, Name} end,
    lists:map(F, Users).
```

Если нам нужно сделать и **map**, и **filter**, то мы можем применить
их по очереди:

```
get_females_id_name(Users) ->
    Users2 = lists:filter(fun({user, _, _, Gender, _}) -> Gender =:= female end, Users),
    lists:map(fun({user, Id, Name, _, _}) -> {Id, Name} end, Users2).
```

Но так мы получим 2 прохода по списку. Можно сделать это в один проход,
если воспользоваться функцией [lists:filtermap/2](http://www.erlang.org/doc/man/lists.html#filtermap-2).

```
get_females_id_name2(Users) ->
    lists:filtermap(fun({user, _, _, male, _}) -> false;
                       ({user, Id, Name, female, _}) -> {true, {Id, Name}}
                    end, Users).
```

Есть много примеров, где функция передается аргументом в другую
функцию.  Но довольно редко бывает, чтобы функция возвращалась как
значение.  Учебные примеры в книгах вы найдете. А что насчет
применения на практике, в реальной работе?  Кое что есть :)

В **EUnit**, фреймворке для модульного тестирования, используются
генераторы юнит тестов.  Они возвращают список функций.

Бывает, что один модуль запрашивает у другого функцию обратного вызова
(callback), чтобы сохранить ее у себя и потом, при каких-то условиях,
вызвать. Второй модуль может определить для этого API-функцию, которая
вернет callback-функцию.

Примеров мало, и это не повседневная практика, а какие-то особые случаи.

Еще с помощью функций, возвращающих функции, можно реализовать ленивые
вычисления.  Кому интересно, почитайте об этом в 9-й главе книги Чезарини.






