# Функции высшего порядка

Функции в эрланг являются обычными значениями. Их можно сохранять в
переменную, передавать в аргументах, возвращать из функции.  Это еще
одна штука, которая отличает функциональные языки от императивных.

Функции высшего порядка (higher-order functions) -- звучит круто, но
ничего особо хитрого здесь нет.  Это всего лишь функции, которые
принимают в аргументах другие функции, или возвращают другие функции.
В упражнении ко второму уроку вы уже реализовали несколько таких.

lists:all/2, lists:any/2, lists:filter/2, lists:dropwhile/2 и т.д. --
все они принимают первым аргументом предикат, который является функцией.

В модуле lists много функций высшего порядка. И самые ходовые из них,
это lists:map/2 и lists:filter/2.

**map** применяет переданную функцию к каждому элементу списка и возвращает
новый список.

```
1> List = [1,2,3,4,5].
[1,2,3,4,5]
2> F = fun(Val) -> Val * 2 end.
 #Fun<erl_eval.6.90072148>
3> lists:map(F, List).
[2,4,6,8,10]
```

```
4> List2 = [{user, 1, "Bob"}, {user, 2, "Bill"}, {user, 3, "Helen"}].
[{user,1,"Bob"},{user,2,"Bill"},{user,3,"Helen"}]
5> F2 = fun({user, Id, Name}) -> {user, Id, string:to_upper(Name)} end.
 #Fun<erl_eval.6.90072148>
6> lists:map(F2, List2).
[{user,1,"BOB"},{user,2,"BILL"},{user,3,"HELEN"}]
```

**filter** использует переданную функцию как предикат для фильтрации списка.

```
7> lists:filter(fun(Val) -> Val > 3 end, List).
[4,5]
8> lists:filter(fun({user, Id, _}) -> Id rem 2 =:= 0 end, List2).
[{user,2,"Bill"}]
```

Мы можем взять примеры из прошлого урока, и переписать их с
использованием map и filter.

Вспомним список пользователей, с которым мы работали:

```
get_users() ->
    [{user, 1, "Bob", male, 22},
     {user, 2, "Helen", female, 14},
     {user, 3, "Bill", male, 11},
     {user, 4, "Kate", female, 18}].
```

Фильтрация пользователей по полу:

```
get_females(Users) ->
    F = fun({user, _, _, male, _}) -> false;
           ({user, _, _, female, _}) -> true
        end,
    lists:filter(F, Users).
```

Получение id и name пользователя:

```
get_id_name(Users) ->
    F = fun({user, Id, Name, _, _}) -> {Id, Name} end,
    lists:map(F, Users).
```

Если нам нужно сделать и **map**, и **filter**, то мы можем применить
их по очереди:

```
get_females_id_name(Users) ->
    Users2 = lists:filter(fun({user, _, _, Gender, _}) -> Gender =:= female end, Users),
    lists:map(fun({user, Id, Name, _, _}) -> {Id, Name} end, Users2).
```

Но так мы получим 2 прохода по списку. Можно сделать это в один проход,
если воспользоваться функцией [lists:filtermap/2](http://www.erlang.org/doc/man/lists.html#filtermap-2).

```
get_females_id_name2(Users) ->
    lists:filtermap(fun({user, _, _, male, _}) -> false;
                       ({user, Id, Name, female, _}) -> {true, {Id, Name}}
                    end, Users).
```

Есть много примеров, где функция передается аргументом в другую
функцию.  Но довольно редко бывает, чтобы функция возвращалась как
значение.  Учебные примеры в книгах вы найдете. А что насчет
применения на практике, в реальной работе?  Кое что есть :)

В **EUnit**, фреймворке для модульного тестирования, используются
генераторы юнит тестов.  Они возвращают список функций.

Бывает, что один модуль запрашивает у другого функцию обратного вызова
(callback), чтобы сохранить ее у себя и потом, при каких-то условиях,
вызвать. Второй модуль может определить для этого API-функцию, которая
вернет callback-функцию.

Примеров мало, и это не повседневная практика, а какие-то особые случаи.

Еще с помощью функций, возвращающих функции, можно реализовать ленивые
вычисления.  Кому интересно, почитайте об этом в 9-й главе книги Чезарини.






