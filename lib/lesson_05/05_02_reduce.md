# Reduce (Fold)

В разных языках эта функция называется по-разному. Где-то она называется **fold** (свертка), а где-то **reduce** (сокращение). Лично мне больше привычно называть fold, как в Эрланг. Но в Эликсир функцию называют reduce. 

Свертка -- важный прием в функциональном программировании. Её понять немного сложнее, чем map и filter. Ну давайте разберемся.

Map и filter принимают на вход список и возвращают список. Reduce принимает список, а возвращает одно значение, то есть, сокращает (сворачивает) список. 

TODO stopped here

[lists:foldl](http://www.erlang.org/doc/man/lists.html#foldl-3) принимает 3 аргумента:

 - функцию сворачивания
 - начальное значение аккумулятора
 - список

Функция сворачивания принимает 2 аргумента: текущий элемент списка и
текущее значение аккумулятора. И должна вернуть новое значение
аккумулятора.

Классический пример -- суммирование и произведение элементов списка:

```
1> List = [1,2,3,4,5].
[1,2,3,4,5]
2> lists:foldl(fun(Item, Acc) -> Acc + Item end, 0, List).
15
3> lists:foldl(fun(Item, Acc) -> Acc * Item end, 1, List).
120
```

Для суммирования начальное значение аккумулятора 0, и потом к нему
прибавляется каждый элемент списка.  Для произведения начальное
значение аккумулятора 1, и потом на него умножается каждый элемент
списка.

Но это учебные примеры, они не интересные :) Давайте сделаем
что-нибудь интересное с нашим списком пользователей:

```
get_users() ->
    [{user, 1, "Bob", male, 22},
     {user, 2, "Helen", female, 14},
     {user, 3, "Bill", male, 11},
     {user, 4, "Kate", female, 18}].
```

Соберем полезную статистику по пользователям: сколько в списке мужчин,
сколько женщин, и средний возраст пользователей.

В качестве аккумулятора возьмем кортеж из 4х чисел:

```
{Males, Females, TotalUsers, TotalAge}
```

Как результат свертки получим этот кортеж, заполненный актуальными данными.

Реализуем:

```
get_stat(Users) ->
    F = fun({user, _, _, Gender, Age}, {Males, Females, TotalUsers, TotalAge}) ->
                case Gender of
                    male -> {Males + 1, Females, TotalUsers + 1, TotalAge + Age};
                    female -> {Males, Females + 1, TotalUsers + 1, TotalAge + Age}
                end
        end,
    lists:foldl(F, {0, 0, 0, 0}, Users).
```

Как видим, тут главное написать сворачивающую функцию, которая пойдет
первым аргументом в lists:foldl, и правильно задать начальное значение
аккумулятора.

Пробуем применить:

```
1> Users = main:get_users().
[{user,1,"Bob",male,22},
 {user,2,"Helen",female,14},
 {user,3,"Bill",male,11},
 {user,4,"Kate",female,18}]
2> {M, F, TU, TA} = main:get_stat(Users).
{2,2,4,65}
```

Средний возраст сразу не получим, но получим данные, чтобы его рассчитать.

```
3> TA / TU.
16.25
```

На прошлом уроке мы изучали рекурсивные функции с аккумуляторами.
Полезно знать, что все, что можно реализовать таким образом, можно
реализовать и через свертку.

Например, мы делили список пользователей по возрасту на два списка:
тех, кому меньше 18, и взрослых:

```
split_by_age(Users) -> split_by_age(Users, {[], []}).

split_by_age([], {Acc1, Acc2}) -> {lists:reverse(Acc1), lists:reverse(Acc2)};

split_by_age([User | Rest], {Acc1, Acc2}) ->
    {user, _, _, _, Age} = User,
    if
        Age < 18 -> split_by_age(Rest, {[User | Acc1], Acc2});
        true -> split_by_age(Rest, {Acc1, [User | Acc2]})
    end.
```

Вот как можно сделать тоже самое через свертку:

```
split_by_age(Users) ->
    lists:foldl(fun(User, {Acc1, Acc2}) ->
                        {user, _, _, _, Age} = User,
                        if
                            Age < 18 -> {[User | Acc1], Acc2};
                            true -> {Acc1, [User | Acc2]}
                        end
                end,
                {[], []},
                Users).
```

Этот пример может показаться менее понятным, чем предыдущий.  Но это
дело привычки. Между тем, рекомендуется применять именно свертку
вместо кастомных рекурсивных функций. Выше уровень абстракции, значит
меньше кода.  Меньше кода, значит меньше возможностей допустить
ошибку.

Теперь понятно, почему на прошлом уроке мы сделали один составной
аккумулятор, вместо 2-х простых. Это было для того, чтобы перейти к
свертке :)

Свертка бывает левая и правая: lists:foldl/3, lists:foldr/3. Левая
начинает от головы списка и идет к хвосту. Правая начинает от хвоста и
идет к голове. Они могут отличаться результатом, а могут не
отличаться, смотря как реализована сворачивающая функция.  Но важно
знать, что левая свертка реализована с хвостовой рекурсией, а правая с
обычной рекурсией, с ростом стека и возвратом назад по стеку.