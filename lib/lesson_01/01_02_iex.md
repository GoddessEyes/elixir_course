# Интерактивная консоль (iex)

```
~/p/elixir_course_junior/lib/lesson_01 $ iex
Erlang/OTP 23 [erts-11.1] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.4) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
```


## Компиляция

The c helper compiled and executed the source file. 
The [] that follows the output is the return value of the c function
if the source file had contained any modules, their names would have been listed here.
```
iex(1)> c "fizz_buzz01.ex"
[FizzBuzz01]
iex(2)> h c
```

r/1 recompiles the given module's source file
recompile/0 recompiles the current project
```
iex(3)> r FizzBuzz01
warning: redefining module FizzBuzz01 (current version defined in memory)
  fizz_buzz01.ex:1

{:reloaded, FizzBuzz01, [FizzBuzz01]} 
```

recompile
```
iex(4)> recompile
Mix is not running. Please start IEx with: iex -S mix
:error
```


## Автокомплит

```
> FizzBuzz01.<tab>
> FizzBuzz01.main
```


## Интроспекция

use the i/1 function to introspect any value
i/0 prints information about the last value
i/1 prints information about the given term

```
iex(4)> i 42
iex(5)> i 3.14
iex(6)> i "hello"
iex(7)> i Map
```


## История

Работают Ctrl-p, Ctrl-n и стрелки вверх-вниз.

v/0 retrieves the last value from the history
v/1 берет значение по номеру строки

```
iex(9)> 42 * 2      
84
iex(10)> v
84
iex(11)> v 9
84
iex(12)> 20 + 30
50
iex(13)> v
50
iex(14)> v 12
50
iex(15)> v 9
84
```


## Справка

h/1 prints help for the given module, function or macro

```
iex> h
iex> h Map
iex> h Map.get
iex> h Map. <Tab>
iex> h Map.fetch
```

b/1 prints callbacks info and docs for a given module

```
iex(21)> b Map
No callbacks for Map were found
iex(22)> b GenServer
...
```

В каждый модуль при компиляции автоматически добавляется функция module_info

```
iex(22)> Map.module_info
iex(23)> FizzBuzz01.module_info
```


## Справка для собственных модулей

```
iex(26)> h FizzBuzz02
FizzBuzz01 was not compiled with docs
```

c("user.exs") compiles the file in memory and does not write the bytecode (.beam file) to disk 
while h/1 currently requires the beam file to be present on disk to work. 
You can make c store the generated bytecode in the current directory.

```
iex(41)> c("fizz_buzz02.ex", ".")
iex(42)> h FizzBuzz02
iex(43)> h FizzBuzz02.main
```

Обычно мы собираем проект с помощью mix, так что beam файлы присутствуют.


## Прочее

```
iex(28)> runtime_info
iex(28)> runtime_info :memory
```

The code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.

Другие фичи:
- отладчик
- remote shell
- .iex.exs file
- настройки

