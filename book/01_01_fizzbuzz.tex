\chapter{Решаем задачу FizzBuzz}

Начнем знакомство с Эликсир на примере решения задачи \name{FizzBuzz}:

\textit{Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz».}

Это простая задача позволит познакомиться со многими важными элементами языка:
\blist
\e модули и функции;
\e генерация списка с помощью \codename{Range};
\e итерация по списку с помощью \codename{Enum.each};
\e условые переходы с помощью \code{cond do};
\e охранные выражения (\code{guards});
\e вывод на консоль;
\e оператор \code{pipe};
\e и модульные тесты (\codename{Unit Tests}).
\elist

\section{Шаг 1. Простая реализация задачи.}

Создаем модуль \codename{FizzBuzz} и в нем две функции \code{main} и \code{fizzbuzz}.

\lstinputlisting[caption=FizzBuzz, language=Elixir, style=elixir]{../lesson_01/lib/fizz_buzz_01.exs}

В функции \code{main} мы генерируем последовательность от 1 до 100. Конструкция \code{1..100} -- это генератор последовательности, он называется \codename{Range}. Затем с помощью \code{Enum.each} мы применяем функцию \code{fizzbuzz} к каждому элементу.

\code{fizzbuzz} использует конструкцию \code{cond do} и охранные выражения (guards) чтобы проверить условия делимости на 3 и на 5. Первое охранное выражение выполняется, если \code{n} делится на 3 и на 5. Второе охранное выражение выполняется, если \code{n} делится на 3. Третье, если \code{n} делится на 5. И последнее, четвертое охранное выражение выполняется всегда, так как оно представлено просто значением \code{true}.

Функция \code{rem}, как не трудно догадаться, возвращает остаток от деления.

\code{cond do} проверяет выражения по очереди, и выполняет только одну ветку кода, соответствующую первому истинному выражению. \code{IO.puts} выводит нужное значение на стандартный вывод.

Соберем и запустим наш код:
\lstinputlisting[caption=Сессия 1, language=ElixirShell, style=elixir-shell]{../lesson_01/lib/session_01.txt}

\section{Шаг 2. Отделяем вывод на консоль от логики.}

Функция \code{fizzbuzz} выводит сообщения на консоль, что не очень хорошо с точки зрения функционального программирования. Разделим нашу задачу на две:

1. Преобразовать список чисел \code{1..100} в другой список, состоящий из чисел и строк: \code{Fizz, Buzz, FizzBuzz}.

2. Вывести результат на консоль.

\lstinputlisting[caption=FizzBuzz02, language=Elixir, style=elixir]{../lesson_01/lib/fizz_buzz_02.exs}

Функция \code{fizzbuzz} теперь стала \name{чистой функцией}. Её результат зависит только от входного значения, и она не делает ничего, кроме вычисления результата. Чистые функции легко понять и протестировать. А так же их легко компоновать друг с другом.

Еще мы сделали небольшую оптимизацию -- вынесли вычисление остатка от деления в отдельное выражение и сохранили результат в переменную. Таким образом мы вычисляем делимость на 3 и на 5 только один раз. В предыдущем решении мы вычисляли это несколько раз.

Мы также добавили \code{@spec} -- спецификацию функции, где описаны типы входящего значения и результата. Хотя Эликсир является языком с динамической типизацией, в нем можно указывать типы для переменных и функций. Компилятор Эликсир не проверяет типы, но есть отдельный инструмент -- \name{dialyzer}, который выполняет статический анализ кода, и в том числе проверку типов.

Вторая задача, вывод результата на консоль, реализована в функции \code{main}. Давайте посмотрим, что здесь изменилось.

Во-первых, мы заменили \code{Enum.each} на \code{Enum.map}. Оба варианта применяют функцию к каждому элементу списка. Но \code{each} игнорирует результаты, а \code{map} собирает их в новый список.

Дальше мы видим оператор \code{pipe}, который позволяет собрать несколько вызовов функций в цепочку, где результат вызова предыдущей функции передается как первый аргумент в следущую функцию. Оператор pipe и такие цепочки функций популярны в Эликсир и являются хорошей практикой.

В нашей цепочке список \code{1..100} передается в \code{Enum.map}, затем новый список передается в \code{Enum.join}, где он склеивается в одну строку. И, наконец, эта строка передается в \code{IO.puts} и выводится на консоль.

Результат выполнения кода немного изменился:

\lstinputlisting[caption=Сессия 2, language=ElixirShell, style=elixir-shell]{../lesson_01/lib/session_02.txt}

Теперь все значения склеены в одну строку, а не выводятся каждое отдельной строкой.

\section{Шаг 3. Юнит-тесты.}

Написать юнит-тест на то, что функция делает правильный вывод на консоль не тривиально. А написать юнит-тест на то, что функция возвращает правильную строку, это тривиально. Чистые функции легко тестировать.

На втором шаге у нас появилась чистая функция \code{fizzbuzz}, которая принимает одно число, и возвращает строку. Но вся задача в целом, fizzbuzz для 100 чисел, пока не представлена чистой функцией. Давайте это исправим:

\lstinputlisting[firstline=2, lastline=12, firstnumber=2, caption=FizzBuzz03, language=Elixir, style=elixir]{../lesson_01/lib/fizz_buzz_03.exs}

Функция \code{fizzbuzz\_100} не принимает аргументов и возвращает список строк. Дальше этот список мы, как и прежде, склеиваем в одну строку и выводим на консоль.

Теперь мы можем протестировать всю задачу целиком.

В Эликсир есть библиотека \name{ExUnit}, которая несмотря на свое название, позволяет писать и юнит-тесты и интеграционные тесты.

Сделаем отдельные тесты для \code{fizzbuzz} и для \code{fizzbuzz\_100}:

\lstinputlisting[firstline=28, lastline=58, firstnumber=28, caption=FizzBuzzTest, language=Elixir, style=elixir]{../lesson_01/lib/fizz_buzz_03.exs}

Как видим, \code{fizzbuzz} тестируется легко. А вот \code{fizzbuzz\_100} возвращает слишком большой список. Проверять его весь нерационально. Поэтому тест проверяет отдельные части этого списка.

\code{Enum.take} берет несколько элементов от головы списка, \code{Enum.drop} отбрасывает несколько элементов и возвращает остаток списка. Комбинация этих двух функций позволяет выделить произвольную часть списка.

Запускаем тесты:

\lstinputlisting[caption=Сессия 3, language=ElixirShell, style=elixir-shell]{../lesson_01/lib/session_03.txt}
