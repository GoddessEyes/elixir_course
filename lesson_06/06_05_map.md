# Использование Map

При моделировании сущностей не редко обходятся просто Map, не прибегая к созданию Module и Struct для каждого случая.

Часто это бывает при активном использовании JSON как формата обмена данными между клиентом и сервером и между серверами. Map напрямую сериализируется в JSON, и, наоборот, JSON десериализируется в Map. А вот чтобы превратить Struct в JSON и обратно, нужно затратить больше усилий.

Важно знать, что Struct -- это уровень абстракции поверх Map. Эта абстракция существует на этапе компиляции, но в рантайме любая Struct это не более, чем Map с дополнительным ключом, указывающим ее тип:
```
> event = StructExample.create
> event.__struct__
Model.Event.Event
> i event
> event_m = Map.from_struct(event)
> i event_m
```

Поэтому почти все что можно сделать с Map, точно так же можно сделать и со Struct. 

Посмотрим, какие возможности предоставляет Эликсир для работы с Map. 

https://hexdocs.pm/elixir/Map.html


## fetch & get

Для извлечения значений из map обычно используют сопоставление с образцом. Но иногда удобно пользоваться функциями модуля Map. Таких функций несколько, рассмотрим некоторые из них.


### Map.fetch

```
fetch(map(), key()) :: {:ok, value()} | :error
```

```
> event = SimpleExample.create_map()
> Map.fetch(event, :title) 
{:ok, "Team Meeting"}
> Map.fetch(event, :topic)
:error
```

Это каноничный функциональный подход. Ожидается использование либо с ветвлением:
```
case Map.fetch(my_map, some_key) do
  {:ok, value} -> do something
  :error -> do something else
end
```
либо, если отсутствие ключа в map является нештатной ситуаций, то с крашем:
```
> {:ok, title} = Map.fetch(event, :title)
{:ok, "Team Meeting"}
> {:ok, topic} = Map.fetch(event, :topic)
** (MatchError) no match of right hand side value: :error
```


### Map.fetch!

```
fetch!(map(), key()) :: value()
```

```
> title = Map.fetch!(event, :title)      
"Team Meeting"
> topic = Map.fetch!(event, :topic)
** (KeyError) key :topic not found in: %{agenda: ...
```

Это не типично для функционального языка. Видимо, влияние Ruby. Эрлангист или другой разработчик с опытом в ФП всегда напишет:
```
{:ok, topic} = Map.fetch(event, :topic)
``` 
И это даст такой же эффект, как:
```
topic = Map.fetch!(event, :topic)
```

Ну почти такой же. Исключения, как мы видим, разные. И, может быть, KeyError тут более уместно, чем MatchError.


### Map.get

```
get(map, key, default \\ nil)
get(map(), key(), value()) :: value()
```

```
iex(11)> Map.get(event, :title)
"Team Meeting"
iex(12)> Map.get(event, :topic)
nil
iex(13)> Map.get(event, :topic, "No topic")
"No topic"
```

Это удобно, когда нужно передать дефолтное значение для отсутствующего ключа. Тру ФП программист не будет ее использовать в варинате с двумя аргументами. Потому что такой программист считает, что nil не годится как дефолтное значение, и вообще ни для чего не годится. Зато в варианте с тремя аргументами он использует Map.get с удовольствием. 


## put

Чтобы добавить ключ в map, есть функции put, put_new и некоторые другие.

### Map.put

```
put(map(), key(), value()) :: map()
```

```
iex(15)> room = event.location.room
%{floor: 6, number: 610}
iex(16)> Map.put(room, :floor, 7)
%{floor: 7, number: 610}
iex(17)> Map.put(room, :size, :big)
%{floor: 6, number: 610, size: :big}
```

Функция обновляет существующий ключ или добавляет новый.


### Map.put_new

```
put_new(map(), key(), value()) :: map()
```

Если обновление существующего ключа -- нежелательный эффект, т.к. мы не хотим по-ошибке затереть его, сделав опечатку, то лучше воспользоваться функцией put_new. 

```
iex(19)> Map.put_new(room, :size, :big)
%{floor: 6, number: 610, size: :big}
iex(20)> Map.put_new(room, :floor, 7)  
%{floor: 6, number: 610}
```

Поведение с существующим ключом на мой взгляд странное -- функция молча возвращает немодифицированную map. Лучше было бы выбросить исключение.


## update

Рассмотрим несколько функций для обновления значений в map.

TODO stopped here

update!/3, update/4, replace, replace!

get_and_update брать, не брать?

```
results =
Map.update(
  results, # look in this map
  hash, # for an entry with key
  [ path ], # if not found, store this value
  fn existing -> # else update with result of this fn
    [ path | existing ]
  end)
```

This wonderful function takes a map, a key, an initial value, and a function. 
If the key is not present in the map, then a new map is returned 
with that key and initial value added. 
If the key is present, then the corresponding value is passed to the function, 
and whatever the function returns becomes the updated value in the returned map.

## split
take, drop, split

## merge
merge/2 merge/3

## map, reduce, filtere
