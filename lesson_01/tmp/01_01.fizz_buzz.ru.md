# Решаем задачу FizzBuzz

Начнем знакомство с Эликсир на примере решения задачи [FizzBuzz](https://ru.wikipedia.org/wiki/Fizz_buzz):

_Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»._

Это простая задача позволит познакомиться со многими важными элементами языка:
- модули и функции;
- генерация списка с помощью `Range`;
- итерация по списку с помощью `Enum.each`;
- условые переходы с помощью `cond do`;
- охранные выражения (guards);
- вывод на консоль;
- оператор pipe;
- и юнит-тесты.

Пока что мы не будем углубляться в суть, а посмотрим беглым взглядом.


## Шаг 1. Простая реализация задачи.

```elixir
{{# source}}fizz_buzz_01.exs{{/ source}}
```

Создаем модуль `FizzBuzz01` и в нем 2 функции `main` и `fizzbuzz`. 

В функции `main` мы генерируем последовательность от 1 до 100. Конструкция `1..100` -- это генератор последовательности, он называется **Range**. Затем с помощью `Enum.each` мы применяем функцию `fizzbuzz` к каждому элементу.

`fizzbuzz` использует конструкцию `cond do` и охранные выражения (guards) чтобы проверить условия делимости на 3 и на 5. Первое охранное выражение выполняется, если `n` делится на 3 и на 5. Второе охранное выражение выполняется, если `n` делится на 3. Третье, если `n` делится на 5. И последнее, четвертое охранное выражение выполняется всегда, так как оно представлено просто значением `true`. 

`cond do` проверяет выражения по очереди, и выполняет только одну ветку кода, соответствующую первому истинному выражению. `IO.puts` выводит нужное значение на стандартный вывод.

Функция `rem`, как не трудно догадаться, возвращает остаток от деления.

Соберем и запустим наш код:

```elixir
{{# source}}session_01.txt{{/ source}}
```


## Шаг 2. Вывод на консоль отделен от логики.

TODO: описать

Добавлены элементы:
- реализация логики как чистой функции;
- указание типа функции с помощью @spec;
- оператор pipe;
- склеивание строк с помощью Enum.join;

```elixir
{{# source}}fizz_buzz_02.exs{{/ source}}
```

Запуск:

```elixir
{{# source}}session_02.txt{{/ source}}
```

## Шаг 3. Юнит-тесты.

TODO: описать

Чистые функции удобны для юнит-тестирования.

Знакомство с фреймворком ExUnit, несколько примеров тестов.

Выделим чистую функцию для удобства тестирования:
```elixir
{{# source}}fizz_buzz_03.exs:fizzbuzz_100{{/ source}}
```

Добавим юнит-тесты:
```elixir
{{# source}}fizz_buzz_03.exs:test{{/ source}}
```

Запуск тестов как elixir-скрипта:

```bash
{{# source}}session_03.txt{{/ source}}
```
