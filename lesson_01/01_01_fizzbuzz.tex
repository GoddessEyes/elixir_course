\chapter{Решаем задачу FizzBuzz}

Начнем знакомство с Эликсир на примере решения задачи \href{https://ru.wikipedia.org/wiki/Fizz_buzz}{FizzBuzz}

\textit{Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz».}

Это простая задача позволит познакомиться со многими важными элементами языка:
\begin{itemize}
\item модули и функции;
\item генерация списка с помощью \texttt{Range};
\item итерация по списку с помощью \texttt{Enum.each};
\item условые переходы с помощью \texttt{cond do};
\item охранные выражения (guards);
\item вывод на консоль;
\item оператор pipe;
\item и модульные тесты (unit tests).
\end{itemize}

\section{Шаг 1. Простая реализация задачи.}

Создаем модуль \textbf{FizzBuzz01} и в нем две функции \texttt{main} и \texttt{fizzbuzz}.

\lstinputlisting[caption=FizzBuzz01]{./lesson_01/lib/fizz_buzz_01.exs}

В функции \texttt{main} мы генерируем последовательность от 1 до 100. Конструкция \texttt{1..100} -- это генератор последовательности, он называется \textbf{Range}. Затем с помощью \texttt{Enum.each} мы применяем функцию \texttt{fizzbuzz} к каждому элементу.

\texttt{fizzbuzz} использует конструкцию \texttt{cond do} и охранные выражения (guards) чтобы проверить условия делимости на 3 и на 5. Первое охранное выражение выполняется, если \texttt{n} делится на 3 и на 5. Второе охранное выражение выполняется, если \texttt{n} делится на 3. Третье, если \texttt{n} делится на 5. И последнее, четвертое охранное выражение выполняется всегда, так как оно представлено просто значением \texttt{true}.

Функция \texttt{rem}, как не трудно догадаться, возвращает остаток от деления.

\texttt{cond do} проверяет выражения по очереди, и выполняет только одну ветку кода, соответствующую первому истинному выражению. \texttt{IO.puts} выводит нужное значение на стандартный вывод.

Соберем и запустим наш код:
\lstinputlisting[caption=Сессия 1]{./lesson_01/lib/session_01.txt}

\section{Шаг 2. Отделяем вывод на консоль от логики.}

Функция \texttt{fizzbuzz} выводит сообщения на консоль, что не очень хорошо с точки зрения функционального программирования. Разделим нашу задачу на две:

1. Преобразовать список чисел \texttt{1..100} в другой список, состоящий из чисел и строк: \texttt{Fizz, Buzz, FizzBuzz}.

2. Вывести результат на консоль.

\lstinputlisting[caption=FizzBuzz02]{./lesson_01/lib/fizz_buzz_02.exs}

Функция \texttt{fizzbuzz} теперь стала \textbf{чистой функцией}. Её результат зависит только от входного значения, и она не делает ничего, кроме вычисления результата. Чистые функции легко понять и протестировать. А так же их легко компоновать друг с другом.

Еще мы сделали небольшую оптимизацию -- вынесли вычисление остатка от деления в отдельное выражение и сохранили результат в переменную. Таким образом мы вычисляем делимость на 3 и на 5 только один раз. В предыдущем решении мы вычисляли это несколько раз.

Мы также добавили \texttt{@spec} -- спецификацию функции, где описаны типы входящего значения и результата. Хотя Эликсир является языком с динамической типизацией, в нем можно указывать типы для переменных и функций. Компилятор Эликсир не проверяет типы, но есть отдельный инструмент -- \textbf{dialyzer}, который выполняет статический анализ кода, и в том числе проверку типов.

Вторая задача, вывод результата на консоль, реализована в функции \texttt{main}. Давайте посмотрим, что здесь изменилось. 

Во-первых, мы заменили \texttt{Enum.each} на \texttt{Enum.map}. Оба варианта применяют функцию к каждому элементу списка. Но \texttt{each} игнорирует результаты, а \texttt{map} собирает их в новый список.

Дальше мы видим оператор \texttt{pipe}, который позволяет собрать несколько вызовов функций в цепочку, где результат вызова предыдущей функции передается как первый аргумент в следущую функцию. Оператор pipe и такие цепочки функций популярны в Эликсир, и являются хорошей практикой.

В нашей цепочке список \texttt{1..100} передается в \texttt{Enum.map}, затем новый список передается в \texttt{Enum.join}, где он склеивается в одну строку. И, наконец, эта строка передается в \texttt{IO.puts} и выводится на консоль.

Результат выполнения кода немного изменился:

\lstinputlisting[caption=Сессия 2]{./lesson_01/lib/session_02.txt}

Теперь все значения склеены в одну строку, а не выводятся каждое отдельной строкой.

\section{Шаг 3. Юнит-тесты.}

Написать юнит-тест на то, что функция делает правильный вывод на консоль не тривиально. А написать юнит-тест на то, что функция возвращает правильную строку, это тривиально. Чистые функции легко тестировать.

На втором шаге у нас появилась чистая функция \texttt{fizzbuzz}, которая принимает одно число, и возвращает строку. Но вся задача в целом, fizzbuzz для 100 чисел, пока не представлена чистой функцией. Давайте это исправим:

\lstinputlisting[firstline=2, lastline=12, firstnumber=2, caption=FizzBuzz03]{./lesson_01/lib/fizz_buzz_03.exs}

Функция \texttt{fizzbuzz\_100} не принимает аргументов и возвращает список строк. Дальше этот список мы, как и прежде, склеиваем в одну строку и выводим на консоль. 

Теперь мы можем протестировать всю задачу целиком.

В Эликсир есть библиотека \textbf{ExUnit}, которая несмотря на свое название, позволяет писать и юнит-тесты и интеграционные тесты.

Сделаем отдельные тесты для \texttt{fizzbuzz} и для \texttt{fizzbuzz\_100}:

\lstinputlisting[firstline=28, lastline=58, firstnumber=28, caption=FizzBuzzTest]{./lesson_01/lib/fizz_buzz_03.exs}

Как видим, \texttt{fizzbuzz} тестируется легко. А вот \texttt{fizzbuzz\_100} возвращает слишком большой список. Проверять его весь нерационально. Поэтому тест проверяет отдельные части этого списка.

\texttt{Enum.take} берет несколько элементов от головы списка, \texttt{Enum.drop} отбрасывает несколько элементов и возвращает остаток списка. Комбинация этих двух функций позволяет выделить произвольную часть списка.

Запускаем тесты:

\lstinputlisting[caption=Сессия 3]{./lesson_01/lib/session_03.txt}
