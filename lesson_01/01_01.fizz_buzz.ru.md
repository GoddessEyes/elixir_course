# Решаем задачу FizzBuzz

Начнем знакомство с Эликсир на примере решения задачи [FizzBuzz](https://ru.wikipedia.org/wiki/Fizz_buzz):

_Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»._

Это простая задача позволит познакомиться со многими важными элементами языка:
- модули и функции;
- генерация списка с помощью `Range`;
- итерация по списку с помощью `Enum.each`;
- условые переходы с помощью `cond do`;
- охранные выражения (guards);
- вывод на консоль;
- оператор pipe;
- и юнит-тесты.

Пока что мы не будем углубляться в суть, а посмотрим беглым взглядом.


## Шаг 1. Простая реализация задачи.

```elixir
defmodule FizzBuzz01 do

  def main() do
    Enum.each(1..100, &fizzbuzz/1)
  end


  def fizzbuzz(n) do
    cond do
      rem(n, 3) == 0 and rem(n, 5) == 0 -> IO.puts("FizzBuzz")
      rem(n, 3) == 0 -> IO.puts("Fizz")
      rem(n, 5) == 0 -> IO.puts("Buzz")
      true -> IO.puts(n)
    end
  end

end
```

Создаем модуль `FizzBuzz01` и в нем 2 функции `main` и `fizzbuzz`. 

В функции `main` мы генерируем последовательность от 1 до 100. Конструкция `1..100` -- это генератор последовательности, он называется **Range**. Затем с помощью `Enum.each` мы применяем функцию `fizzbuzz` к каждому элементу.

`fizzbuzz` использует конструкцию `cond do` и охранные выражения (guards) чтобы проверить условия делимости на 3 и на 5. Первое охранное выражение выполняется, если `n` делится на 3 и на 5. Второе охранное выражение выполняется, если `n` делится на 3. Третье, если `n` делится на 5. И последнее, четвертое охранное выражение выполняется всегда, так как оно представлено просто значением `true`. 

`cond do` проверяет выражения по очереди, и выполняет только одну ветку кода, соответствующую первому истинному выражению. `IO.puts` выводит нужное значение на стандартный вывод.

Функция `rem`, как не трудно догадаться, возвращает остаток от деления.

Соберем и запустим наш код:

```elixir
iex(1)> c "lib/fizz_buzz_01.exs"
[FizzBuzz01]
iex(2)> FizzBuzz01.main()
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
...
97
98
Fizz
Buzz
:ok
```


## Шаг 2. Отделяем вывод на консоль от логики.

Функция `fizzbuzz` выводит сообщения на консоль, что не очень хорошо с точки зрения функционального программирования. Разделим нашу задачу на две:

1. Преобразовать список чисел `1..100` в другой список, состоящий из чисел и строк "Fizz", "Buzz", "FizzBuzz".

2. Вывести результат на консоль.

```elixir
defmodule FizzBuzz02 do

  def main() do
    1..100
    |> Enum.map(&fizzbuzz/1)
    |> Enum.join(" ")
    |> IO.puts()
  end


  @spec fizzbuzz(integer) :: String.t
  def fizzbuzz(n) do
    divisible_by_3 = rem(n, 3) == 0
    divisible_by_5 = rem(n, 5) == 0
    cond do
      divisible_by_3 and divisible_by_5 -> "FizzBuzz"
      divisible_by_3 -> "Fizz"
      divisible_by_5 -> "Buzz"
      true -> to_string(n)
    end
  end

end
```

Функция `fizzbuzz` теперь стала **чистой функцией**. Её результат зависит только от входного значения, и она не делает ничего, кроме вычисления результата. Чистые функции легко понять и протестировать. А так же их легко компоновать друг с другом.

Еще мы сделали небольшую оптимизацию -- вынесли вычисление остатка от деления в отдельное выражение и сохранили результат в переменную. Таким образом, мы вычисляем делимость на 3 и на 5 только один раз. В предыдущем решении мы вычисляли это несколько раз.

Мы также добавили `@spec` -- спецификацию функции, где описаны типы входящего значения и результата. Хотя Эликсир является языком с динамической типизацией, в нем можно указывать типы для переменных и функций. Компилятор Эликсир не проверяет типы, но есть отдельный инструмент -- **dialyzer**, который выполняет статический анализ кода, и в том числе проверку типов.

Вторая задача, вывод результата на консоль, реализована в функции `main`. Давайте посмотрим, что здесь изменилось. 

Во-первых, мы заменили `Enum.each` на `Enum.map`. Оба варианта применяют функцию к каждому элементу списка. Но `each` игнорирует результаты, а `map` собирает их в новый список.

Дальше мы видим оператор **pipe**, который позволяет собрать несколько вызовов функций в цепочку, где результат вызова предыдущей функции передается как первый аргумент в следущую функцию. Оператор pipe и такие цепочки функций популярны в Эликсир, и являются хорошей практикой.

В нашей цепочке список `1..100` передается в `Enum.map`, затем новый список передается в `Enum.join`, где он склеивается в одну строку. И, наконец, эта строка передается в `IO.puts` и выводится на консоль.

Результат выполнения кода немного изменился:

```elixir
iex(1)> c "lib/fizz_buzz_02.exs"
[FizzBuzz02]
iex(2)> FizzBuzz02.main()
1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz
 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 B
uzz Fizz 37 38 Fizz Buzz 41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz F
izz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz 61 62 Fizz 64 Buzz Fizz 6
7 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz Fizz 82 83 
Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz 
Buzz                                                               
:ok
```

Теперь все значения склеены в одну строку, а не выводятся каждое отдельной строкой.


## Шаг 3. Юнит-тесты.

Написать юнит-тест на то, что функция делает правильный вывод на консоль не тривиально. А написать юнит-тест на то, что функция возвращает правильную строку, это тривиально. Чистые функции легко тестировать.

На втором шаге у нас появилась чистая функция `fizzbuzz`, которая принимает одно число, и возвращает строку. Но вся задача в целом, fizzbuzz для 100 чисел, пока не представлена чистой функцией. Но это легко сделать:

```elixir
def main() do
    fizzbuzz_100()
    |> Enum.join(" ")
    |> IO.puts()
  end


  @spec fizzbuzz_100() :: [String.t]
  def fizzbuzz_100() do
    1..100
    |> Enum.map(&fizzbuzz/1)
  end
```

Функция `fizzbuzz_100` не принимает аргументов и возвращает список строк. Дальше этот список мы, как и прежде, склеиваем в одну строку и выводим на консоль. 

Теперь мы можем протестировать всю задачу целиком.

В Эликсир есть библиотека **ExUnit**, которая несмотря на свое название, позволяет писать и юнит-тесты и интеграционные тесты.

Сделаем отдельные тесты для `fizzbuzz` и для `fizzbuzz_100`:

```elixir
ExUnit.start()

defmodule FizzBuzzTest do
  use ExUnit.Case
  import FizzBuzz03

  test "fizzbuzz 1-10" do
    assert fizzbuzz(1) == "1"
    assert fizzbuzz(2) == "2"
    assert fizzbuzz(3) == "Fizz"
    assert fizzbuzz(4) == "4"
    assert fizzbuzz(5) == "Buzz"
    assert fizzbuzz(6) == "Fizz"
    assert fizzbuzz(7) == "7"
    assert fizzbuzz(8) == "8"
    assert fizzbuzz(9) == "Fizz"
    assert fizzbuzz(10) == "Buzz"
  end

  test "fizzbuzz 15, 30" do
    assert fizzbuzz(15) == "FizzBuzz"
    assert fizzbuzz(30) == "FizzBuzz"
  end

  test "fizzbuzz_100" do
    res = fizzbuzz_100()
    assert Enum.take(res, 5) == ["1", "2", "Fizz", "4", "Buzz"]
    assert res |> Enum.drop(9) |> Enum.take(6) == ["Buzz", "11", "Fizz", "13", "14", "FizzBuzz"]
  end
end
```

Как видим, `fizzbuzz` тестируется легко. А вот `fizzbuzz_100` возвращает слишком большой список. Проверят его весь нерационально. Поэтому тест проверяет отдельные части этого списка.

`Enum.take` берет несколько элементов от головы списка, `Enum.drop` отбрасывает несколько элементов и возвращает остаток списка. Комбинация этих двух функций позволяет вырезать произвольную часть списка.

Запускаем тесты:

```bash
$ elixir lib/fizz_buzz_03.exs
...

Finished in 0.03 seconds (0.03s on load, 0.00s on tests)
3 tests, 0 failures

Randomized with seed 681561
```
