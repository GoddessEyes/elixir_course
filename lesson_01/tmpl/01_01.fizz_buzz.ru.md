# Решаем задачу FizzBuzz

Начнем знакомство с Эликсир на примере решения задачи [FizzBuzz](https://ru.wikipedia.org/wiki/Fizz_buzz):

_Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»._

Это простая задача позволит познакомиться со многими важными элементами языка:
- модули и функции;
- генерация списка с помощью `Range`;
- итерация по списку с помощью `Enum.each`;
- условые переходы с помощью `cond do`;
- охранные выражения (guards);
- вывод на консоль;
- оператор pipe;
- и юнит-тесты.

Пока что мы не будем углубляться в суть этих элементов, а посмотрим на них беглым взглядом.


## Шаг 1. Простая реализация задачи.

```elixir
{{# source}}fizz_buzz_01.exs{{/ source}}
```

Создаем модуль `FizzBuzz01` и в нем две функции `main` и `fizzbuzz`. 

В функции `main` мы генерируем последовательность от 1 до 100. Конструкция `1..100` -- это генератор последовательности, он называется **Range**. Затем с помощью `Enum.each` мы применяем функцию `fizzbuzz` к каждому элементу.

`fizzbuzz` использует конструкцию `cond do` и охранные выражения (guards) чтобы проверить условия делимости на 3 и на 5. Первое охранное выражение выполняется, если `n` делится на 3 и на 5. Второе охранное выражение выполняется, если `n` делится на 3. Третье, если `n` делится на 5. И последнее, четвертое охранное выражение выполняется всегда, так как оно представлено просто значением `true`. 

Функция `rem`, как не трудно догадаться, возвращает остаток от деления.

`cond do` проверяет выражения по очереди, и выполняет только одну ветку кода, соответствующую первому истинному выражению. `IO.puts` выводит нужное значение на стандартный вывод.

Соберем и запустим наш код:

```
{{# source}}session_01.txt{{/ source}}
```


## Шаг 2. Отделяем вывод на консоль от логики.

Функция `fizzbuzz` выводит сообщения на консоль, что не очень хорошо с точки зрения функционального программирования. Разделим нашу задачу на две:

1. Преобразовать список чисел `1..100` в другой список, состоящий из чисел и строк "Fizz", "Buzz", "FizzBuzz".

2. Вывести результат на консоль.

```elixir
{{# source}}fizz_buzz_02.exs{{/ source}}
```

Функция `fizzbuzz` теперь стала **чистой функцией**. Её результат зависит только от входного значения, и она не делает ничего, кроме вычисления результата. Чистые функции легко понять и протестировать. А так же их легко компоновать друг с другом.

Еще мы сделали небольшую оптимизацию -- вынесли вычисление остатка от деления в отдельное выражение и сохранили результат в переменную. Таким образом мы вычисляем делимость на 3 и на 5 только один раз. В предыдущем решении мы вычисляли это несколько раз.

Мы также добавили `@spec` -- спецификацию функции, где описаны типы входящего значения и результата. Хотя Эликсир является языком с динамической типизацией, в нем можно указывать типы для переменных и функций. Компилятор Эликсир не проверяет типы, но есть отдельный инструмент -- **dialyzer**, который выполняет статический анализ кода, и в том числе проверку типов.

Вторая задача, вывод результата на консоль, реализована в функции `main`. Давайте посмотрим, что здесь изменилось. 

Во-первых, мы заменили `Enum.each` на `Enum.map`. Оба варианта применяют функцию к каждому элементу списка. Но `each` игнорирует результаты, а `map` собирает их в новый список.

Дальше мы видим оператор **pipe**, который позволяет собрать несколько вызовов функций в цепочку, где результат вызова предыдущей функции передается как первый аргумент в следущую функцию. Оператор pipe и такие цепочки функций популярны в Эликсир, и являются хорошей практикой.

В нашей цепочке список `1..100` передается в `Enum.map`, затем новый список передается в `Enum.join`, где он склеивается в одну строку. И, наконец, эта строка передается в `IO.puts` и выводится на консоль.

Результат выполнения кода немного изменился:

```
{{# source}}session_02.txt{{/ source}}
```

Теперь все значения склеены в одну строку, а не выводятся каждое отдельной строкой.


## Шаг 3. Юнит-тесты.

Написать юнит-тест на то, что функция делает правильный вывод на консоль не тривиально. А написать юнит-тест на то, что функция возвращает правильную строку, это тривиально. Чистые функции легко тестировать.

На втором шаге у нас появилась чистая функция `fizzbuzz`, которая принимает одно число, и возвращает строку. Но вся задача в целом, fizzbuzz для 100 чисел, пока не представлена чистой функцией. Давайте это исправим:

```elixir
{{# source}}fizz_buzz_03.exs:fizzbuzz_100{{/ source}}
```

Функция `fizzbuzz_100` не принимает аргументов и возвращает список строк. Дальше этот список мы, как и прежде, склеиваем в одну строку и выводим на консоль. 

Теперь мы можем протестировать всю задачу целиком.

В Эликсир есть библиотека **ExUnit**, которая несмотря на свое название, позволяет писать и юнит-тесты и интеграционные тесты.

Сделаем отдельные тесты для `fizzbuzz` и для `fizzbuzz_100`:

```elixir
{{# source}}fizz_buzz_03.exs:test{{/ source}}
```

Как видим, `fizzbuzz` тестируется легко. А вот `fizzbuzz_100` возвращает слишком большой список. Проверять его весь нерационально. Поэтому тест проверяет отдельные части этого списка.

`Enum.take` берет несколько элементов от головы списка, `Enum.drop` отбрасывает несколько элементов и возвращает остаток списка. Комбинация этих двух функций позволяет выделить произвольную часть списка.

Запускаем тесты:

```
{{# source}}session_03.txt{{/ source}}
```
