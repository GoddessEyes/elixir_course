# Интерактивная консоль (iex)

Посмотрим на интерактивную консоль -- второй по важности, после редактора, инструмент разработчика.

Многие языки программирования имеют REPL консоль. Она дает возможность работать интеративно: запускать небольшие куски кода и сразу же видеть результ. REPL означает Read, Eval, Print, Loop. То есть, консоль читает код, выполняет его, выводит результат, и опять читает код.

Мы уже начали активно пользоваться консолью когда реализовывали FizzBuzz, и в процессе активно переключались между редактором кода и консолью.

Теперь познакомимся с ней поближе:

```elixir
{{# source}}session_04.txt:start{{/ source}}
```

Мы видим версию Эрланг: `Erlang/OTP 23`, версию Erlang Runtime System: `erts-11.1` и версию Эликсир: `Elixir (1.13.4)`.


## Компиляция

Консоль имеет много встроенных функций. Самые популярные из них имеют короткие названия, зачастую в одну букву. 

Мы уже пользовались функцией `c`, которая компилирует и загружает код:

```elixir
{{# source}}session_04.txt:compile{{/ source}}
```

Другая популярная функция -- это `h`, которая показывает справку по функциям и модулям Эликсир. Посмотрим справку по функции `c`:

```elixir
{{# source}}session_04.txt:compile_help{{/ source}}
```

Мы видим, что функция `c` компилирует один или несколько файлов, загружает их в память консоли, или сохраняет сгенерированный байт-код по указаному пути. 

Если мы вносим изменения в код, то с помощью функции `r` мы можем перекомпилировать модуль заново и загрузить свежую версию.

```elixir
{{# source}}session_04.txt:recompile{{/ source}}
```

Таким образом удобно вести интерактивную разработку -- писать код и тут же проверять в консоли, как он работает. 

Для больших проектов неудобно перекомпилировать по-отдельности каждый измененный модуль. Поэтому в консоли есть функция `recompile`, которая пересобирает весь проект. Однако, для этого нужно иметь полноценный проект с правильной структурой кода, а не просто несколько модулей.


## Автодополнение

Для кода, который скомпилирован и загружен в консоль, работает автодополнение модулей и функций:

```elixir
{{# source}}session_04.txt:autocomplete{{/ source}}
```

## Интроспекция

Еще одна полезная короткая функция -- это `i`. Это интроспеция, которая показывает информацию о значениях и переменных:

```elixir
{{# source}}session_04.txt:introspection{{/ source}}
```

## История

TODO stopped here

Работают Ctrl-p, Ctrl-n и стрелки вверх-вниз.

v/0 retrieves the last value from the history
v/1 берет значение по номеру строки

```elixir
{{# source}}session_04.txt:history{{/ source}}
```


## Справка

h/1 prints help for the given module, function or macro

```elixir
{{# source}}session_04.txt:help{{/ source}}
```

b/1 prints callbacks info and docs for a given module

```elixir
{{# source}}session_04.txt:module_help{{/ source}}
```

В каждый модуль при компиляции автоматически добавляется функция module_info

```elixir
{{# source}}session_04.txt:module_info{{/ source}}
```


## Справка для собственных модулей

```elixir
{{# source}}session_04.txt:fizzbuzz_help{{/ source}}
```

c("user.exs") compiles the file in memory and does not write the bytecode (.beam file) to disk
while h/1 currently requires the beam file to be present on disk to work.
You can make c store the generated bytecode in the current directory.

```elixir
{{# source}}session_04.txt:fizzbuzz_help_2{{/ source}}
```

Обычно мы собираем проект с помощью mix, так что beam файлы присутствуют.


## Прочее

```elixir
{{# source}}session_04.txt:runtime_info{{/ source}}
```

The code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.

Другие фичи:
- отладчик
- remote shell
- .iex.exs file
- настройки
