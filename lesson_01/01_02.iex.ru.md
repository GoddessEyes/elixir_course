# Интерактивная консоль (iex)

Посмотрим на интерактивную консоль -- второй по важности, после редактора, инструмент разработчика.

Многие языки программирования имеют REPL консоль. Она дает возможность работать интеративно: запускать небольшие куски кода и сразу же видеть результ. REPL означает Read, Eval, Print, Loop. То есть, консоль читает код, выполняет его, выводит результат, и опять читает код.

Мы уже начали активно пользоваться консолью когда реализовывали FizzBuzz, и в процессе активно переключались между редактором кода и консолью.

Теперь познакомимся с ней поближе:

```elixir
~/p/elixir_course_junior/lib/lesson_01 $ iex
Erlang/OTP 23 [erts-11.1] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

Interactive Elixir (1.13.4) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)>
```

Мы видим версию Эрланг: `Erlang/OTP 23`, версию Erlang Runtime System: `erts-11.1` и версию Эликсир: `Elixir (1.13.4)`.


## Компиляция

Консоль имеет много встроенных функций. Самые популярные из них имеют короткие названия, зачастую в одну букву. 

Мы уже пользовались функцией `c`, которая компилирует и загружает код:

```elixir
iex(1)> c "lib/fizz_buzz_02.exs"
[FizzBuzz02]
```

Другая популярная функция -- это `h`, которая показывает справку по функциям и модулям Эликсир. Посмотрим справку по функции `c`:

```elixir
iex(2)> h c
def c(files, path \\ :in_memory)
Compiles the given files.
...
```

Мы видим, что функция `c` компилирует один или несколько файлов, загружает их в память консоли, или сохраняет сгенерированный байт-код по указаному пути. 

Если мы вносим изменения в код, то с помощью функции `r` мы можем перекомпилировать модуль заново и загрузить свежую версию.

```elixir
iex(3)> r FizzBuzz02
warning: redefining module FizzBuzz02 (current version defined in memory)
  lib/fizz_buzz_02.exs:1

{:reloaded, [FizzBuzz02]}
```

Таким образом удобно вести интерактивную разработку -- писать код и тут же проверять в консоли, как он работает. 

Для больших проектов неудобно перекомпилировать по-отдельности каждый измененный модуль. Поэтому в консоли есть функция `recompile`, которая пересобирает весь проект. Однако, для этого нужно иметь полноценный проект с правильной структурой кода, а не просто несколько модулей.


## Автодополнение

Для кода, который скомпилирован и загружен в консоль, работает автодополнение модулей и функций:

```elixir
> Fizz.<tab>
> FizzBuzz02.<tab>
> FizzBuzz02.m<tab>
> FizzBuzz02.main
```

## Интроспекция

Еще одна полезная короткая функция -- это `i`. Это интроспеция, которая показывает информацию о значениях и переменных:

```elixir
iex(4)> i 42
Term
  42
Data type
  Integer
...

iex(5)> i 3.14
Term
  3.14
Data type
  Float
...

iex(6)> my_str = "Hello"
iex(7)> i my_str
Term
  "Hello"
Data type
  BitString
Byte size
  5
Description
  This is a string: a UTF-8 encoded binary ...
  
iex(8)> my_list = [1, 2, 3]
iex(9)> i my_list
Term
  [1, 2, 3]
Data type
  List
...
```

## История

TODO stopped here

Работают Ctrl-p, Ctrl-n и стрелки вверх-вниз.

v/0 retrieves the last value from the history
v/1 берет значение по номеру строки

```elixir
iex(9)> 42 * 2
84
iex(10)> v
84
iex(11)> v 9
84
iex(12)> 20 + 30
50
iex(13)> v
50
iex(14)> v 12
50
iex(15)> v 9
84
```


## Справка

h/1 prints help for the given module, function or macro

```elixir
iex> h
iex> h Map
iex> h Map.get
iex> h Map. <Tab>
iex> h Map.fetch
```

b/1 prints callbacks info and docs for a given module

```elixir
iex(21)> b Map
No callbacks for Map were found
iex(22)> b GenServer
...
```

В каждый модуль при компиляции автоматически добавляется функция module_info

```elixir
iex(22)> Map.module_info
iex(23)> FizzBuzz01.module_info
```


## Справка для собственных модулей

```elixir
iex(26)> h FizzBuzz02
FizzBuzz01 was not compiled with docs
```

c("user.exs") compiles the file in memory and does not write the bytecode (.beam file) to disk
while h/1 currently requires the beam file to be present on disk to work.
You can make c store the generated bytecode in the current directory.

```elixir
iex(41)> c("fizz_buzz02.ex", ".")
iex(42)> h FizzBuzz02
iex(43)> h FizzBuzz02.main
```

Обычно мы собираем проект с помощью mix, так что beam файлы присутствуют.


## Прочее

```elixir
iex(28)> runtime_info
iex(28)> runtime_info :memory
```

The code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.

Другие фичи:
- отладчик
- remote shell
- .iex.exs file
- настройки
