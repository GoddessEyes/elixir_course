# Рекурсия

В Эликсир, как и во всех функциональных языках, нет циклов. Их заменяет рекурсия.


## Пример 1

Начнем сразу с практики, рассмотрим пример функции, которая вычисляет длину списка:

```elixir
> c "lib/recursion.exs"
[Recursion]
> alias Recursion, as: R
> R.len([1,2,3,4,5])
5
> R.len([])
0
```

Функция `len` состоит из двух тел. Первое тело вызывается на пустом списке, и это наше условие выхода из рекурсии. Здесь все просто -- длина пустого списка 0. Второе тело вызывается на непустом списке, и это один шаг (одна итерация) обработки списка.

Здесь мы делаем классическое для функционального программирования разделения списка на голову и хвост:

```elixir
[_head | tail]
```

(Переменная `_head` в дальнейшем не используется, поэтому её имя начинается с подчеркивания). Здесь логика тоже очень простая -- длина списка, это 1 плюс длина хвоста списка.

На каждой итерации список уменьшается на один элемент, пока не становится пустым. А пустой список попадает в первое тело функции, что завершает рекурсию.

Для списка `[1, 2, 3, 4, 5]` стек вызовов функции будет выглядеть так:

```elixir
len([1,2,3,4,5])
1 + len([2,3,4,5])
1 + 1 + len([3,4,5])
1 + 1 + 1 + len([4,5])
1 + 1 + 1 + 1 + len([5])
1 + 1 + 1 + 1 + 1 + len([])
1 + 1 + 1 + 1 + 1 + 0
```


## Пример 2

Возьмем пример немного сложнее, реализуем функцию, которая возвращает максимальный элемент в списке.

```elixir
> r R
> R.list_max([1,3,33,42,100500,-10])
100500
> R.list_max([1])
1
> R.list_max([])
nil
```

Нюанс в том, что в пустом списке нет максимального элемента, так что нужно вернуть `nil`. Условием завершения рекурсии будет список из одного элемента. Очевидно, что этот элемент и есть максимальный элемент.

 И третье тело функции реализует шаг итерации на списке, содержащем больше одного элемента. Опять делим список на голову и хвост. Чтобы найти максимальный элемент, нужно сравнить голову с максимальным элементом хвоста.

Для списка `[1, 3, 33, 42]` стек вызовов будет выглядеть так:

```elixir
list_max([1,3,33,42])
max(1, list_max([3,33,42]))
max(1, max(3, list_max([33,42])))
max(1, max(3, max(33, list_max([42]))))
max(1, max(3, max(33, 42)))
max(1, max(3, 42))
max(1, 42)
42
```

## Пример 3

Реализуем функцию, которая принимает два числа, задающих диапазон, и возвращает список, заполненный числами в этом диапазоне.

```elixir
> R.range(1,5)
[1, 2, 3, 4, 5]
> R.range(2,2)
[2]
> R.range(3,2)
[]
```

Особенность этой функции в том, что выход рекурсии здесь реализован во втором теле, а не в первом. Так тоже бывает, хоть и не часто.


## Пример 4

Реализуем функцию, которая меняет местами пары чисел в списке.

```elixir
> r R
> R.swap_pair([1,2,3,4])
[2, 1, 4, 3]
> R.swap_pair([1,2,3])
** (RuntimeError) Can't swap a list with an odd number of elements
```

Здесь две особенности. Во-первых, функция извлекает не одну голову из списка, а сразу две. Оператор `cons` позволяет извлекать одновременно несколько элементов. Во-вторых, функция предъявляет требование к входящим данным -- список должен иметь четное количество элементов.


TODO Еще неплохо было бы придумать пример опосредованой рекурсии, через 2 функции.


## Стратегии рекурсии

TODO: поискать больше инфы по этой теме. В UA не особо хорошо описано.

**Decrease and conquer**

Постепенное уменьшение задачи шаг за шагом, приходящее к тривиальному случаю.

Все примеры выше относятся к этой стратегии.


**Divide and conquer**

Разделяем задачу на две (или больше) частей, каждую из которых можно решать независимо, затем объединяем полученные результаты.

Хорошим примером этой стратегии является алгоритмы сортировки **quick sort** и **merge sort**.

Однако, алгоритмы сортировки являются слабым местом функционального программирования. И сама по себе структура List для этого плохо подходит, и иммутабельность в данном случае мешает.

Еще хороший пример стратегии divide and conquer -- рекурсивная обработка древовидных структур данных. 
