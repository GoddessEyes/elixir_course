# Рекурсивные функции с аккумуляторами

Типичный способ работы со списками -- использование рекурсивных функций и аккумуляторов. Рассмотрим эту тему на конкретных примерах.


## Пример 1

Допустим, у нас есть список пользователей:

```elixir
> c "lib/recursion_with_acc.exs"
> alias RecursionWithAcc, as: RA
> RA.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
```

И мы хотим отфильтровать совершеннолетних пользователей. То есть, получить новый список, где будут только пользователи старше 16 лет.

Применим рекурсивную функцию с аккумулятором:

```elixir
> users = RA.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> RA.filter_adults(users)
[{:user, 2, "Helen", 20}, {:user, 1, "Bob", 23}]
```

Функция получает на вход два аргумента: список пользователей, и список, где будет накапливаться результат выполнения -- аккумулятор. В начале выполнения список пользователей полный, а аккумулятор пустой. На каждом шаге итерации мы будем брать один элемент из первого списка, и, если он нам нужен, то класть его в аккумулятор. В итоге первый список опустошится, а аккумулятор наполнится.

Наша рекурсивная функция имеет два тела (_clause_). Первое тело выполняется, когда список пользователей пустой. То есть, это завершение фильтрации. И тут нужно просто отдать накопленный результат.

Второе тело и делает всю работу. Сперва список пользователей с помощью оператора cons делится на голову и хвост (это можно делать прямо в описании аргументов функции).  Голова -- это текущий элемент списка, который мы будем анализировать. Хвост -- это остаток списка, который мы передадим дальше, в следующий рекурсивный вызов.

Анализ элемента тут простой: определяем возраст пользователя. Пользователей младше 16 лет мы игнорируем, а старше добавляем в аккумулятор, опять с помощью оператора cons.

Элементы в аккумуляторе накапливаются в обратном порядке. Если это не важно, то аккумулятор можно вернуть, как есть. Если желательно сохранить оригинальный порядок, то аккумулятор нужно развернуть.


## Пример 2

Второй пример. Допустим, из списка пользователей нужно извлечь их идентификаторы и имена. То есть, получить список кортежей вида:

```elixir
{id, name}
```

Делаем:

```elixir
> RA.get_id_name(users)
[{1, "Bob"}, {2, "Helen"}, {3, "Bill"}, {4, "Kate"}]
```

Опять два тела у функции. Первое тело отвечает за завершение рекурсии и возврат результата, накопленного в аккумуляторе.

Второе тело обрабатывает каждый элемент списка, извлекает из кортежа

```elixir
{:user, id, name, age}
```

нужные id и name, и сохраняет их в аккумуляторе.

Хорошая практика -- предлагать как публичный АПИ функцию с одним аргументом. А функцию с аккумулятором скрывать от пользователей модуля. Потому что аккумулятор может быть сложнее, чем просто список, и пользователям модуля незачем об этом знать.


## Пример 3

И вот пример со сложным аккумулятором. Допустим нам нужно разделить пользователей на два списка: несовершеннолетние и взрослые.

```elixir
> TA.split_teens_and_adults(users)
{[{:user, 3, "Bill", 15}, {:user, 4, "Kate", 14}],
 [{:user, 1, "Bob", 23}, {:user, 2, "Helen", 20}]}

```

В этот раз наш аккумулятор -- это кортеж из двух списков. В первом теле функции, как обычно, возвращаем результат. И тут мы разворачиваем оба списка. Во втором теле функции обрабатываем каждый элемент списка, извлекаем и проверяем возраст. Тех, кто моложе 16 лет, кладем в первый список в аккумуляторе, остальных во второй список.
