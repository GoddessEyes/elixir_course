# Системные типы (System types)

## Служебные идентификаторы

**pid** является идентификатором потока, зная который, можно отправлять потоку сообщения.

```
iex(1)> f = fn -> :ok end
#Function<45.97283095/0 in :erl_eval.expr/5>
iex(2)> pid = spawn(f)
#PID<0.110.0>
iex(3)> send(pid, :hello)
:hello
```

**port** является идентификатором специального процесса, связанного с сокетом.

```
iex(4)> :gen_tcp.listen(8080, [])
{:ok, #Port<0.6>}
iex(5)> :gen_udp.open(9090)
{:ok, #Port<0.7>}
```

**reference** является идентификатором общего назначения, который можно использовать по своему усмотрению. Например, как ключ для хранения объекта в ets таблице. Или им можно пометить сообщение, отправленное другому потоку, и ждать ответное сообщение, помеченное тем же ключом.

```
iex(6)> make_ref()
#Reference<0.2063296336.1072955394.111887>
```

BEAM гарантирует, что make_ref при каждом вызове генерирует новый уникальный ключ.


## function

Конечно, функциональный язык не может обойтись без анонимных функций, они же лямбды, они же замыкания. Для них тоже есть отдельный тип данных. Эти функции можно сохранять в переменную, передавать как аргументы в другие функции, и даже посылать на другую ноду, чтобы выполнить там.

```
iex(19)> my_fun = fn(arg) -> arg * 2 end
#Function<44.97283095/1 in :erl_eval.expr/5>
iex(20)> my_fun.(24)
48
iex(22)> my_fun.(my_fun.(42))
168

iex(25)> apply_twice = fn(f, arg) -> f.(f.(arg)) end
iex(26)> apply_twice.(my_fun, 42)
168

iex(18)> f = fn(val) -> rem(val, 2) == 0 end
iex(19)> Enum.filter([1,2,3,4,5], f)
[2, 4]
```


## Некоторые нюансы типов данных в BEAM

Простые и составные типы данных.
Условность этого разделения (pid простой или составной?)

Сравнение значений

Операция сравнения определена для любого значения. То есть, любое значение любого типа можно сравнивать с любым другим значением.

number < atom < reference < function < port < pid < tuple < map < list < binary

TODO пример: сортировка списка с разнородными данными
