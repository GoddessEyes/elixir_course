# Системные типы (System types)

## Служебные идентификаторы

**pid** является идентификатором процесса.

```
iex(1)> f = fn -> :ok end
#Function<45.97283095/0 in :erl_eval.expr/5>
iex(2)> pid = spawn(f)
#PID<0.110.0>
iex(3)> send(pid, :hello)
:hello
```

Наш процесс выполняет функцию `f` и сразу же завершается. Но его `pid` остаётся у нас, и мы можем отправить сообщение.


**port** является идентификатором специального процесса, связанного с сокетом.

Мы можем открыть TCP-сокет:
```
iex(5)> {:ok, tcp_socket} = :gen_tcp.listen(8080, [])
{:ok, #Port<0.4>}
iex(6)> :gen_tcp.close(tcp_socket)
:ok
```

Или UDP-сокет:
```
iex(8)> {:ok, udp_socket} = :gen_udp.open(9090)
{:ok, #Port<0.5>}
iex(9)> :gen_udp.close(udp_socket)
:ok
```

Через него можно взаимодействовать с сокетом -- отправлять и читать данные.


**reference** -- уникальное значение, идентификатор, который можно использовать по своему усмотрению. Например, как ключ для хранения объекта в ets таблице. Также им можно пометить сообщение, отправленное другому процессу, и ждать ответное сообщение, помеченное тем же ключом.

```
iex(6)> make_ref()
#Reference<0.2063296336.1072955394.111887>
```

BEAM гарантирует, что make_ref при каждом вызове генерирует новый уникальный ключ.


## function

Конечно, функциональный язык не может обойтись без анонимных функций, они же лямбды, они же замыкания. Для функций тоже есть отдельный тип данных. Их можно сохранять в переменную, передавать как аргументы в другие функции и даже посылать на другой узел в кластере, чтобы выполнить там.

Сохраняем анонимную функцию в переменную:
```
iex(19)> my_fun = fn(arg) -> arg * 2 end
#Function<44.97283095/1 in :erl_eval.expr/5>
iex(20)> my_fun.(5)
10
iex(22)> my_fun.(my_fun.(5))
20
iex(23)> other_name = my_fun
iex(42)> other_name.(42)
10
```

В переменную можно сохранить и именованую функцию:
```
iex(16)> my_sort = &Enum.sort/1
&Enum.sort/1
iex(17)> my_sort.([5, 1, 3, 10])
[1, 3, 5, 10]
```

Передаём функцию как аргумент в другую функцию:
```
iex(25)> apply_twice = fn(f, arg) -> f.(f.(arg)) end
iex(26)> apply_twice.(my_fun, 5)
20
```

Более реалистичные примеры:
```
iex(18)> even? = fn(val) -> rem(val, 2) == 0 end
iex(19)> Enum.filter([1, 2, 3, 4, 5], even?)
[2, 4]
iex(23)> Enum.map([1,2,3,4,5], my_fun)
[2, 4, 6, 8, 10]
```


## Сравнение значений

Операция сравнения определена для любого значения. То есть, любое значение любого типа можно сравнивать с любым другим значением.

Cуществует порядок сравнения разных типов друг с другом:
```
number < atom < reference < function < port < pid < tuple < map < list < binary
```

Это необычное поведение. В большинстве языков программирования операция сравнения имеет смысл только для значений одного типа. Но такой дизайн Эликсир принял от Эрланг.

Примеры сравнения:
```
iex(27)> 42 > :ok
false
iex(28)> :ok > make_ref()
false
iex(29)> make_ref() > my_fun
false
iex(30)> my_fun > [1,2,3]
false
```

Пример сортировки значений разных типов:
```
iex(1)> list = [1, :ok, 100, %{a: 42}, [1,3,2], "Hello"]
[1, :ok, 100, %{a: 42}, [1, 3, 2], "Hello"]
iex(2)> Enum.sort(list)
[1, 100, :ok, %{a: 42}, [1, 3, 2], "Hello"]
```
