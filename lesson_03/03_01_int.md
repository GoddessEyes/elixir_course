# Int

Целое число со знаком. Диапазон значений не ограничен. Памяти выделяется столько, сколько нужно, чтобы хранить значение. В большинстве случаев это будет 1 машинное слово (4 байта на 32-х разрядной платформе, 8 байт на 64-х разрядной). Если число большое, и для его хранения не хватает машинного слова, то памяти выделяется больше.

Это удобно для программиста, но не очень эффективно по производительности. Поэтому для эрланг не характерны высокопроизводительные операции с числами.

Целые числа могут быть представлены разными способами. В разных системах исчесления: в десятичной, шеснадцатиричной, восьмеричной и двоичной:

```elixir
42
0x2A
0o52
0b101010
```

В экспоненциальном виде:

```elixir
0.42e2
```

Для больших чисел можно использовать символ подчеркивания между разрядами для удобства чтения:
```elixir
100_500
1_000_000
```

Arithmetic operators
+ - * / div rem


## gcd

Наибольший общий делитель

Остаток от деления.
rem заимствует знак первого аргумента для результата
```
iex(13)> rem(12, 9)
3
iex(14)> rem(12, -9)
3
iex(15)> rem(-12, -9)
-3
iex(16)> rem(-12, 9)
-3
```
Для сравнения, в питоне оператор % заимствует знак второго аргумента
```
>>> 12 % 9
3
>>> 12 % -9
-6
>>> -12 % 9
6
```

Поведение gcd для отрицательных чисел и для нуля можно придумывать самому. Или подсмотреть где-нибудь.

В питоне math.gcd игнорирует знаки аргументов, и в случае 0 возвращает ненулевой аргумент (или 0, если оба 0).

Отдельными шагами реализуем обработку отрицательных чисел и нуля.

Запуск gcd:
```
iex(1)> c "lib/lesson_03/task_03_01_int.exs"
[GCDTest, Lesson_03_01_Int]
iex(2)> alias Lesson_03.Task_03_01_Int, as: TI
iex(3)> TI.gcd(9, 15)
3
```

Запуск тестов:
```
elixir lib/lesson_03/task_03_01_int.exs
```
