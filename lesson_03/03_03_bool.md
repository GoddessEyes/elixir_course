# Булевые значения (Boolean)

Булевый тип в Эликсир представлен значениями `true` и `false`. Сюда же можно отнести и значение `nil`, выражающее отсутствие информации. 

На самом деле все эти три значения являются атомами, но язык интерпретирует их отдельно от остальных атомов и реализует для них операторы двоичной логики.

**Строгие операторы** `and`, `or`, `not` работают только со значениями `true` и `false`:

```elixir-iex
iex(1)> true and true
true
iex(2)> true and false
false
iex(3)> true or true
true
iex(4)> true or false
true
iex(5)> not true
false
iex(6)> not false
true
```

Попробуем с не-булевыми значениями:

```elixir-iex
iex(1)> 1 and true
** (BadBooleanError) expected a boolean on left-side of "and", got: 1
    iex:1: (file)
iex(1)> 1 or true
** (BadBooleanError) expected a boolean on left-side of "or", got: 1
    iex:1: (file)
iex(1)> 1 and false
** (BadBooleanError) expected a boolean on left-side of "and", got: 1
    iex:1: (file)
iex(1)> 1 or false
** (BadBooleanError) expected a boolean on left-side of "or", got: 1
    iex:1: (file)
iex(1)> true and 1
1
iex(2)> true or 1
true
iex(3)> false and 1
false
iex(4)> false or 1
1
```

Как видим, эта строгость срабатывает только если не-булевое значение стоит справа. А если слева, то срабатывает ленивость этих операторов, которые не вычисляют всё выражение целиком, если без этого можно обойтись.

**Мягкие (relaxed) операторы** `&&`, `||`, `!` работают с любыми значениями. При этом `false` и `nil` интерпретируются как `false`, а любые другие значения интерпретируются как `true`. Пустой список и пустой словарь тоже интерпретируются как `true`. Это отличает Эликсир от других языков, например от Python.

В английской терминологии в контексте мягких операторов значения `false` и `nil` называют **falsy**, а все остальные значения называют **truthy**. Русский перевод подобрать трудно :)

```elixir
iex(5)> 1 && true
true
iex(6)> 1 || nil
1
iex(7)> ! 42
false
iex(8)> ! nil
true
```

TODO пример, включая [], {}
TODO проверить, как это в Python


Оператор `&&` в успешном случае возвращает свой второй аргумент, в неуспешном случае возвращает неуспешный аргумент:

```elixir
true && 42  # успешно, второй аргумент, 42
42 && true  # успешно, второй аргумент, true
false && 42 # не успешно, false
nil && 42   # не успешно, nil
42 && nil   # не успешно, nil
```

Есть еще варианты:

```elixir
false && nil # false
nil && false # nil
```

Но можно не запоминать их, так как на практике это не так важно.

Оператор `||` в успешном случае возвращает успешный аргумент:

```elixir
42 || false  # 42
false || 42  # 42
nil || false # false
false || nil # nil
```

Оператор `!` возвращает `true` или `false` при любых аргументах:

```elixir
! 42    # false
! true  # false
! false # true
! nil   # true
```

И строгие, и мягкие операторы являются ленивыми. То есть, они вычисляют только часть выражения, если этого достаточно:

```elixir
IO.puts("a") && IO.puts("b") # => a b
IO.puts("a") || IO.puts("b") # => a
true or IO.puts("b")         # true
false and IO.puts("b")       # false
```

Некоторые разработчики используют их для вывода сообщения об ошибке в случае неуспешной операции:

```elixir
do_something() || Logger.error("some error")
```

## Упражнение

Таблицы истинности для троичной логики Стивена Клини
https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0

Table: NOT(A)

| A     | NOT A |
|-------|-------|
| false | true  |
| nil   | nil   |
| true  | false |


Table: AND(A, B)

| AND   | false | nil   | true  |
| false | false | false | false |
| nil   | false | nil   | nil   |
| true  | false | nil   | true  |


Table: OR(A, B)

| OR    | false | nil  | true |
| false | fasle | nil  | true |
| nil   | nil   | nil  | true |
| true  | true  | true | true |


Step1 -- копируем таблицу как есть.
Tests -- покрываем тестами.
Step2 -- оптимизируем реализацию.

```
iex(1)> c "lib/lesson_03/task_03_03_bool.exs"
[Lesson_03.Task_03_03_Bool]
iex(2)> alias Lesson_03.Task_03_03_Bool, as: TB
Lesson_03.Task_03_03_Bool
iex(3)> TB.sk_not true
false
iex(4)> TB.sk_and true, nil
nil
iex(5)> TB.sk_or true, nil
true
```

Запуск тестов:
```
elixir lib/lesson_03/task_03_03_bool.exs
```
