# Атомы и кортежи

**Атомы** типичны для функциональных языков, но редко встречаются в языках императивных. 

Программисты на Ruby знакомы с Symbol, это тоже самое, что атомы. Но, например, в Python или JavaScript такого типа данных нет.

Атомы, это некие константные значения, которые можно сравнивать друг с другом. Собственно, сравнивать — это единственное, что с ними можно делать. Сами по себе они не очень полезны, но становятся полезны в комплекте с кортежами и сопоставлением с образцом (pattern matching).

Вместо атомов можно было бы использовать обычные строки. Но атомы занимают мало места в памяти, всего 4 байта, и поэтому эффективнее строк. Их можно рассматривать как человекочитаемые синонимы для числовых констант.

Атом начинается либо с большой буквы:

```elixir
User
Point
IP_Address
```

либо с двоеточия:

```elixir
:user
:point
:ip_address
```

**Кортеж (tuple)** — это структура данных, объединяющая несколько разных значений. Кортеж похож на список, но в отличие от списка имеет фиксированную длину. 

Примеры:

```elixir
{"Bob", :male, 23}
{1, 2}
{127, 0, 0, 1}
```

Часто в кортежах на первой позиции ставят атом, чтобы обозначить, какие данные собраны в кортеже. Таким образом кортеж помечается тэгом, и это называется **тэгированный кортеж (tagged tuple)**:

```elixir
{:user, "Bob", :male, 23}
{:point, 1, 2}
{:ip_address, 127, 0, 0, 1}
```

Тегированные кортежи не так часто используются в Эликсир, но очень часто в Эрланг и других функциональных языках.

Кортежи могут быть вложенными:

```elixir
{:rectangle, {:point, 0, 0}, {:point, 10, 10}}
{:ip4, {127, 0, 0, 1}}
```

Небольшие объекты, состоящие из 2-х - 4-х полей, удобно представлять в виде кортежей, если роль полей понятна из контекста. Если полей больше 4-х, то лучше использовать **словарь (map)** или **структуру (struct)**.

Атомы и кортежи — это легковесные объекты, они используют меньше памяти, чем словари и структуры, и операции над ними выполняются быстрее.

Для работы с ними часто используется **сопоставление с образцом (pattern matching)**. По этой теме у нас будет отдельный урок. Сейчас важно знать, что это способ извлечь отдельные значения из кортежа.

Создаём кортеж:

```elixir-iex
iex(1)> my_point = {:point, 5, 10}
{:point, 5, 10}
```

Извлекаем значения из кортежа:

```elixir-iex
iex(2)> {:point, x, y} = my_point
{:point, 5, 10}
iex(3)> x
5
iex(4)> y
10
```

Извлечь значения можно с помощью функции `elem/2`:

```elixir-iex
iex(5)> elem(my_point, 1)
5
iex(6)> elem(my_point, 2)
10
```

Но на практике эту функцию используют крайне редко, потому что сопоставление с образцом удобнее.

## Упражнение

Реализуем функцию `distance/2`, которая вычисляет расстояние между двумя точками:

```elixir
defmodule AtomTupleExample do
  def distance(point1, point2) do
    {:point, x1, y1} = point1
    {:point, x2, y2} = point2
    x_dist = abs(x1 - x2)
    y_dist = abs(y1 - y2)
    :math.sqrt(:math.pow(x_dist, 2) + :math.pow(y_dist, 2))
  end
end
```

Здесь мы извлекам координаты каждой точки, вычисляем абсолютное расстояние по горизонтали и по вертикали, и затем вычиляем расстояние по диагонали с помощью теоремы Пифагора.

Функция `abs/1` возвращает модуль числа. Мы применяем её, чтобы получить абсолютное значение для расстояний по горизонтали и по вертикали. Это необязательно делать, так как мы потом возводим эти значения в квадрат. Но поскольку мы применяем теорему Пифагора, то полезно представить себе треугольник. А треугольник со сторонами отрицательной длины представить трудно :)

Для извлечения корня и возведения в квадрат применяется модуль **:math** из стандартной библиотеки языка Эрланг. Эликсир переопределяет большинство модулей Эрланг, но модуль **:math** не переопределяет. Любые библиотеки и модули Эрланг можно использовать в Эликсир.

В Эрланг принято называть модули с маленькой буквы -- `:math`, в Эликсир принято называть модули с большой буквы -- `Math`. В обоих случаях имена модулей являются атомами. 

Значения из кортежей часто извлекают прямо в агрументах функции:

```elixir
defmodule AtomTupleExample do
  def distance({:point, x1, y1}, {:point, x2, y2}) do
    x_dist = abs(x1 - x2)
    y_dist = abs(y1 - y2)
    :math.sqrt(:math.pow(x_dist, 2) + :math.pow(y_dist, 2))
  end
end
```

Результат работы функции:

```elixir
distance({:point, 0, 0}, {:point, 0, 5})  # 5.0
distance({:point, 2, 2}, {:point, 10, 12})  # 12.806248474865697
distance({:point, -5, -5}, {:point, 10, 10})  # 21.213203435596427
```

```
iex(6)> c "lib/lesson_03/task_03_04_atom_tuple.exs"
[Lesson_03.Task_03_04_AtomTuple]
iex(7)> import Lesson_03.Task_03_04_AtomTuple
Lesson_03.Task_03_04_AtomTuple
iex(8)> p1 = {:point, 1, 1}
{:point, 1, 1}
iex(9)> p2 = {:point, 10, 10}
{:point, 10, 10}
iex(10)> distance(p1, p2)
12.727922061357855
```

```
elixir lib/lesson_03/task_03_04_atom_tuple.exs
```

Реализовать функцию is_point_inside_figure для прямоугольника и круга.


Точка представлена кортежем `{:point, x, y}`.

Окружность представлена кортежем `{:circle, center, radius}`, где center — это кортеж `:point`.

Прямоугольник представлен кортежем `{:rect, left_top, right_bottom}`, где left_top и right_bottom — это кортежи `:point`.

TODO: в скринкасте я использовал @type и @spec. Стоит ли их вводить на данном этапе? Собственно, @spec уже был на самом первом занятии. А @type удобный способ формально описать, что такое point, circle, rect.

TODO: я сперва сделал `point_inside_cirle?` и `point_inside_rect?`, а потом обобщил до `point_inside_figure?`. Есть смысл это сохранить.

TODO: code and sessions from templates
