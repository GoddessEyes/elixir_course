# Списки (List)

Список -- основная структура данных, рабочая лошадка всех функциональных языков. А в некоторых языках (в Lisp) -- это вообще единственная структура данных, заменяющая все остальные :)

Представляет собой **однонаправленный связный список** (linked list). Каждый элемент списка состоит из двух частей: некое значение и ссылка на следующий элемент. Список можно обходить по ссылкам от головы первого элемента) к последнему. В обратном направлении пройти нельзя, потому что обратных ссылок нет.

Хорошее понимание устройства списков и способов их использования очень важно, поэтому им будет посвящен отдельный урок. Там я постараюсь объяснить, почему именно однонаправленный связный список является основной структурой данных, а не массив и не, например, двунаправленный связный список.


Создадим список:

```elixir-iex
iex(1)> my_list = [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
```

Две основные операции над списком, это добавление нового элемента к голове:


```elixir-iex
iex(2)> [0 | my_list]
[0, 1, 2, 3, 4, 5]
```

и разделение списка на голову (первый элемент) и хвост (все остальные элементы):

```elixir-iex
iex(3)> [head | tail] = my_list
[1, 2, 3, 4, 5]
iex(4)> head
1
iex(5)> tail
[2, 3, 4, 5]
```

Как мы позже увидим, из этих двух операций строятся любые простые и сложные способы работы со списком.

Кортежи и списки являются коллекциями, то есть, содержат в себе несколько элементов. Кортеж является коллекцией фиксированного размера, он не меняется в рантайме. Список -- это динамическая коллекция, он может расти и уменьшаться.

В Эликсир списки могут содержать элементы любых типов:

```elixir-iex
iex(1)> [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
iex(2)> [:red, :green, :blue]
[:red, :green, :blue]
iex(3)> [4.5, 77, :hi, 'yo', "hello"]
[4.5, 77, :hi, 'yo', "hello"]
```

А также могут быть вложенными друг в друга на несколько уровней:

```elixir-iex
iex(4)>[1, 2, [3, 4, [5, 6], 7], 8, 9]
[1, 2, [3, 4, [5, 6], 7], 8, 9]
```

Списки могут содержать внутри себя кортежи:

```elixir-iex
iex(1)> [{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
[{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
```

А кортежи могут содержать внутри себя списки:

```elixir-iex
iex(1)> {:field, {:width, 10}, {:height, 20}, {:points, [{:point, 1,2}, {:point, 3,4}]}}
{:field, {:width, 10}, {:height, 20},
{:points, [{:point, 1, 2}, {:point, 3, 4}]}}
```

С помощью вложенных друг в друга кортежей и списков можно описать любые, даже очень сложные по структуре данные. 

TODO: хорошо бы подобрать пример на Эликсир, а не на Эрланг.
https://github.com/yzh44yzh/erma

```erlang
{select,["email.email","address.state","account.name"],
        {"user",as,"u"},
        [{joins,[{left,{"email",as,"e"},[{pk,"eid"}]},
                 {left,"address",[{fk,"addr_id"}]},
                 {left,"account",[{pk,"aid"},{fk,"acc_id"}]}]}]
```

Правда, в Эликсир (в отличие от Эрланг) такой подход обычно не используется. Потому что есть более высокоуровневые типы данных.

## Упражнение

Реализуем операцию `merge` из алгоритма **merge sort** -- слить два отсортированых списка в один.

На уровне виртуальной машины списки могут быть реализованы как мутабельные массивы, и поэтому сортируются эффективными алгоритмами в мутабельной памяти.
Но от разработчика детали реализации скрыты, на уровне кода списки являются иммутабельными связными списками.

Сортировку связных списков трудно сделать эффективно. Но операцию merge -- легко.

TODO: описание задачи
TODO: описание реализации. Рекурсия с аккумулятором.
TODO: тесты на реализацию
TODO: сессия, несколько примеров merge

```elixir-eix
iex(1)> c "lib/list_example.exs"
[ListExample, ListExampleTest]
iex(2)> ListExample.merge([5, 6, 10], [1, 3, 8, 13])
[1, 3, 5, 6, 8, 10, 13]
```

Запуск тестов:

```shell
elixir lib/list_example.exs
..
Finished in 0.06 seconds (0.06s on load, 0.00s async, 0.00s sync)
2 tests, 0 failures

Randomized with seed 496805
```

## Домашнее задание

Функция `merge/2` проверяет, что оба списка предварительно отсортированы, и бросает исключение, если это не так.
