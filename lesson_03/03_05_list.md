### List

Список -- основная структура данных. Рабочая лошадка всех функциональных языков. А в некоторых языках (в Lisp) -- это вообще единственная структура данных, заменяющая все остальные :)

Представляет собой однонаправленный связанный список (linked list). Каждый элемент списка состоит из двух частей: некое значение и ссылка на следующий элемент. Список можно обходить по ссылкам от головы (первого элемента) к последнему. В обратном направлении пройти нельзя, потому что обратных ссылок нет.

A list may either be empty or consist of a head and a tail. The head contains a value and the tail is itself a list.
This recursive definition of a list is the core of much Elixir programming.

Lists are easy to traverse linearly, but they are expensive to access in random order.

Хорошее понимание устройства списков и способов их использования очень важно, поэтому следующий урок будет целиком посвящен им. Там я постараюсь объяснить, почему именно однонаправленный связанный список является основной структурой данных, а не массив, и не, например, двунаправленный связанный список.

В эрланге списки могут содержать элементы разных типов:

1> [1,2,3,4,5].
[1,2,3,4,5]
2> [red, green, blue].
[red,green,blue]
3> [4.5, 77, hi, "hello", <<"hello">>].
[4.5,77,hi,"hello",<<"hello">>]

Могут быть вложенными друг в друга на несколько уровней:

4> [1, 2, [3, 4, [5, 6], 7], 8, 9].
[1,2,[3,4,[5,6],7],8,9]

Могут содержать кортежи:

5> [{point, 1, 2}, {point, 3, 4}, {point, 5, 6}].
[{point,1,2},{point,3,4},{point,5,6}]

И кортежи могут содержать внутри себя списки:

6> {field, {width, 10}, {height, 20}, {points, [{point, 1,2}, {point, 3,4}]}}.
{field,{width,10},
    {height,20},
    {points,[{point,1,2},{point,3,4}]}}


С помощью вложенных друг в друга кортежей и списков можно описать любые, даже очень сложные по структуре данные:

{select,["email.email","address.state","account.name"],
        {"user",as,"u"},
        [{joins,[{left,{"email",as,"e"},[{pk,"eid"}]},
                 {left,"address",[{fk,"addr_id"}]},
                 {left,"account",[{pk,"aid"},{fk,"acc_id"}]}]}]

Правда в Эликсир (в отличие от Эрланг), такой подход обычно не используется. Потому что есть более высокоуровневые типы данных.


Упражнение: 
операция merge из алгоритма merge sort. Слить два сортированых списка в один.
```
iex(1)> c "lib/lesson_03/task_03_05_list.exs"
[Lesson_03.Task_03_05_List, Task_05_Test]
iex(2)> alias Lesson_03.Task_03_05_List, as: TL
iex(3)> TL.merge([5,6,10], [1,3,8,13])
[1, 3, 5, 6, 8, 10, 13]
```

Запуск тестов
```
elixir lib/lesson_03/task_03_05_list.exs
```

Домашнее задание: 
Функция merge проверяет, что оба списка предварительно отсортированы, и бросает исключение, если это не так.

