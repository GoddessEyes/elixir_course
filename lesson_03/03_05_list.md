# Списки (List)

Список -- основная структура данных, рабочая лошадка всех функциональных языков. А в некоторых языках (в Lisp) -- это вообще единственная структура данных, заменяющая все остальные :)

Представляет собой **однонаправленный связный список** (linked list). Каждый элемент списка состоит из двух частей: некое значение и ссылка на следующий элемент. Список можно обходить по ссылкам от головы первого элемента) к последнему. В обратном направлении пройти нельзя, потому что обратных ссылок нет.

Хорошее понимание устройства списков и способов их использования очень важно, поэтому им будет посвящен отдельный урок. Там я постараюсь объяснить, почему именно однонаправленный связный список является основной структурой данных, а не массив и не, например, двунаправленный связный список.

TODO: основные операции на списком, перенести сюда из lesson 05
- добавить новый элемент к голове
- разделить список на голову и хвост.

TODO: кортеж фиксированного размера, список -- динамическая структура, меняется, растет и уменьшается.
TODO: может содержать значения разных типов, хотя на практике такое редко бывает нужно.

В Эликсир списки могут содержать элементы разных типов:

```elixir
iex(1)> [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
iex(2)> [:red, :green, :blue]
[:red, :green, :blue]
iex(3)> [4.5, 77, :hi, 'yo', "hello"]
[4.5, 77, :hi, 'yo', "hello"]
```

А также могут быть вложенными друг в друга на несколько уровней:

```elixir
iex(4)>[1, 2, [3, 4, [5, 6], 7], 8, 9]
[1, 2, [3, 4, [5, 6], 7], 8, 9]
```

Ещё могут содержать кортежи:

```elixir
iex(1)> [{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
[{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
```

А кортежи могут содержать внутри себя списки:

```elixir
iex(1)> {:field, {:width, 10}, {:height, 20}, {:points, [{:point, 1,2}, {:point, 3,4}]}}
{:field, {:width, 10}, {:height, 20},
{:points, [{:point, 1, 2}, {:point, 3, 4}]}}
```

TODO: нужно подумать, как это показать в live coding, не тратя много времени, чтобы набрать все это с клавиатуры. То есть, подготовить примеры в exs.

С помощью вложенных друг в друга кортежей и списков можно описать любые, даже очень сложные по структуре данные:
https://github.com/yzh44yzh/erma

```erlang
{select,["email.email","address.state","account.name"],
        {"user",as,"u"},
        [{joins,[{left,{"email",as,"e"},[{pk,"eid"}]},
                 {left,"address",[{fk,"addr_id"}]},
                 {left,"account",[{pk,"aid"},{fk,"acc_id"}]}]}]
```

Правда, в Эликсир (в отличие от Эрланг) такой подход обычно не используется. Потому что есть более высокоуровневые типы данных.

## Упражнение

Реализуем операцию `merge` из алгоритма **merge sort** -- слить два отсортированых списка в один.

На уровне виртуальной машины списки могут быть реализованы как мутабельные массивы, и поэтому сортируются эффективными алгоритмами в мутабельной памяти.
Но от разработчика детали реализации скрыты, на уровне кода списки являются иммутабельными связными списками.

Сортировку связных списков трудно сделать эффективно. Но операцию merge -- легко.

TODO: описание задачи
TODO: описание реализации. Рекурсия с аккумулятором.
TODO: тесты на реализацию
TODO: сессия, несколько примеров merge

```elixir-eix
iex(1)> c "lib/list_example.exs"
[ListExample, ListExampleTest]
iex(2)> ListExample.merge([5, 6, 10], [1, 3, 8, 13])
[1, 3, 5, 6, 8, 10, 13]
```

Запуск тестов:

```shell
elixir lib/list_example.exs
..
Finished in 0.06 seconds (0.06s on load, 0.00s async, 0.00s sync)
2 tests, 0 failures

Randomized with seed 496805
```

## Домашнее задание

Функция `merge/2` проверяет, что оба списка предварительно отсортированы, и бросает исключение, если это не так.
