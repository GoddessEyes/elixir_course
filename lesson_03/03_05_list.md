### List

Список -- основная структура данных. Рабочая лошадка всех функциональных языков. А в некоторых языках (в Lisp) -- это вообще единственная структура данных, заменяющая все остальные :)

Представляет собой однонаправленный связанный список (linked list). Каждый элемент списка состоит из двух частей: некое значение и ссылка на следующий элемент. Список можно обходить по ссылкам от головы (первого элемента) к последнему. В обратном направлении пройти нельзя, потому что обратных ссылок нет.

```
[ 1 | * ] -> [ 2 | * ] -> ... -> [ n | _ ] 
```

Список может быть либо пустым, либо состоять из головы и хвоста. Голова содержит значение, а хвост сам по себе является списком. Это рекурсивное определение списка лежит в основе большей части программирования на Эликсире.

Стоит помнить! Списки легко проходить линейно, но получение n-го элемента - дорогая операция, ибо будет необходимо пройти от начала до нужного элемента. 

Хорошее понимание устройства списков и способов их использования очень важно, поэтому следующий урок будет целиком посвящен им. Там я постараюсь объяснить, почему именно однонаправленный связанный список является основной структурой данных, а не массив, и не, например, двунаправленный связанный список.

В Эликсире списки могут содержать элементы разных типов:

```elixir
iex(1)> [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
iex(2)> [:red, :green, :blue]
[:red, :green, :blue]
iex(3)> [4.5, 77, :hi, 'yo', "hello"]
[4.5, 77, :hi, 'yo', "hello"]
```

А также могут быть вложенными друг в друга на несколько уровней:

```elixir
iex(4)>[1, 2, [3, 4, [5, 6], 7], 8, 9]
[1, 2, [3, 4, [5, 6], 7], 8, 9]
```

Ещё могут содержать кортежи:
```elixir
iex(1)> [{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
[{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
```

А кортежи могут содержать внутри себя списки:
```elixir
iex(1)> {:field, {:width, 10}, {:height, 20}, {:points, [{:point, 1,2}, {:point, 3,4}]}}
{:field, {:width, 10}, {:height, 20},
 {:points, [{:point, 1, 2}, {:point, 3, 4}]}}
```


С помощью вложенных друг в друга кортежей и списков можно описать любые, даже очень сложные по структуре данные:
https://github.com/yzh44yzh/erma

```erlang
{select,["email.email","address.state","account.name"],
        {"user",as,"u"},
        [{joins,[{left,{"email",as,"e"},[{pk,"eid"}]},
                 {left,"address",[{fk,"addr_id"}]},
                 {left,"account",[{pk,"aid"},{fk,"acc_id"}]}]}]
```
Правда в Эликсир (в отличие от Эрланг), такой подход обычно не используется. Потому что есть более высокоуровневые типы данных.


Упражнение:
операция merge из алгоритма merge sort. Слить два сортированых списка в один.
```
iex(1)> c "lib/lesson_03/task_03_05_list.exs"
[Lesson_03.Task_03_05_List, Task_05_Test]
iex(2)> alias Lesson_03.Task_03_05_List, as: TL
iex(3)> TL.merge([5,6,10], [1,3,8,13])
[1, 3, 5, 6, 8, 10, 13]
```

Запуск тестов
```
elixir lib/lesson_03/task_03_05_list.exs
```

Домашнее задание:
Функция merge проверяет, что оба списка предварительно отсортированы, и бросает исключение, если это не так.
