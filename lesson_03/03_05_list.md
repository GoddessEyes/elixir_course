### List

Список -- основная структура данных. Рабочая лошадка всех функциональных языков. А в некоторых языках (в Lisp) -- это вообще единственная структура данных, заменяющая все остальные :)

Представляет собой однонаправленный связанный список (linked list). Каждый элемент списка состоит из двух частей: некое значение и ссылка на следующий элемент. Список можно обходить по ссылкам от головы (первого элемента) к последнему. В обратном направлении пройти нельзя, потому что обратных ссылок нет.

Хорошее понимание устройства списков и способов их использования очень важно, поэтому следующий урок будет целиком посвящен им. Там я постараюсь объяснить, почему именно однонаправленный связанный список является основной структурой данных, а не массив, и не, например, двунаправленный связанный список.

В Эликсире списки могут содержать элементы разных типов:

```elixir
iex(1)> [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
iex(2)> [:red, :green, :blue]
[:red, :green, :blue]
iex(3)> [4.5, 77, :hi, 'yo', "hello"]
[4.5, 77, :hi, 'yo', "hello"]
```

TODO: кортеж фиксированного размера, список -- динамическая структура, меняется, растет и уменьшается.
TODO: может содержать значения разных типов, хотя на практике такое редко бывает нужно.

TODO: основные операции на списком, перенести сюда из lesson 05
- добавить новый элемент к голове
- разделить список на голову и хвост.

А также могут быть вложенными друг в друга на несколько уровней:

```elixir
iex(4)>[1, 2, [3, 4, [5, 6], 7], 8, 9]
[1, 2, [3, 4, [5, 6], 7], 8, 9]
```

Ещё могут содержать кортежи:
```elixir
iex(1)> [{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
[{:point, 1, 2}, {:point, 3, 4}, {:point, 5, 6}]
```

А кортежи могут содержать внутри себя списки:
```elixir
iex(1)> {:field, {:width, 10}, {:height, 20}, {:points, [{:point, 1,2}, {:point, 3,4}]}}
{:field, {:width, 10}, {:height, 20},
 {:points, [{:point, 1, 2}, {:point, 3, 4}]}}
```
TODO: нужно подумать, как это показать в live coding, не тратя много времени, чтобы набрать все это с клавиатуры. То есть, подготовить примеры в exs.


С помощью вложенных друг в друга кортежей и списков можно описать любые, даже очень сложные по структуре данные:
https://github.com/yzh44yzh/erma

```erlang
{select,["email.email","address.state","account.name"],
        {"user",as,"u"},
        [{joins,[{left,{"email",as,"e"},[{pk,"eid"}]},
                 {left,"address",[{fk,"addr_id"}]},
                 {left,"account",[{pk,"aid"},{fk,"acc_id"}]}]}]
```
Правда в Эликсир (в отличие от Эрланг), такой подход обычно не используется. Потому что есть более высокоуровневые типы данных.


Упражнение:

операция merge из алгоритма merge sort. Слить два сортированых списка в один.

На уровне виртуальной машины списки могут быть реализованы как мутабельные массивы, и поэтому сортируются эффективными алгоритмами в мутабельной памяти.
Но от разработчика детали реализации скрыты, на уровне кода списки являются иммутабельными связанными списками. 

Сортировку связаных списков трудно сделать эффективно. Но операцию merge -- легко.

TODO: описание задачи
TODO: описание реализации. Рекурсия с аккумулятором.
TODO: тесты на реализацию
TODO: сессия, несколько примеров merge

```
iex(1)> c "lib/lesson_03/task_03_05_list.exs"
[Lesson_03.Task_03_05_List, Task_05_Test]
iex(2)> alias Lesson_03.Task_03_05_List, as: TL
iex(3)> TL.merge([5,6,10], [1,3,8,13])
[1, 3, 5, 6, 8, 10, 13]
```

Запуск тестов
```
elixir lib/lesson_03/task_03_05_list.exs
```

Домашнее задание:
Функция merge проверяет, что оба списка предварительно отсортированы, и бросает исключение, если это не так.
