# Сложные типы (Complex types)

## IO List

Рекурсивный тип данных, который состоит из:
- byte (число в диапазоне 0-255)
- [byte] (список таких чисел)
- String.t (бинарная строка)
- IO List (включает сам себя)

TODO: пример

```
> ... |> flatten()
"Hello world!"
```

Такой тип поддерживается во всех операциях ввода-вывода и позволяет избежать дорогостоящей конкатенации строк.

Не эффективно:

```elixir-iex
iex(8)> header = "<html><body>"
"<html><body>"
iex(9)> footer = "</body></html>"
"</body></html>"
iex(10)> name = "Bob"
"Bob"
iex(11)> body = "hello " <> name <> "!"
"hello Bob!"
iex(12)> page = header <> body <> footer
iex(15)> IO.puts page
<html><body>hello Bob!</body></html>
```
TODO:
page = title <> body
html = header <> page <> footer

Здесь много операций по копированию строк из одной области памяти в другую, чтобы в итоге результат разместился в одной непрерывной области памяти.

Эффективно:

```elixir-iex
iex(8)> header = "<html><body>"
"<html><body>"
iex(9)> footer = "</body></html>"
"</body></html>"
iex(10)> name = "Bob"
"Bob"
iex(13)> body_io = ["hello ", name, "!"]
["hello ", "Bob", "!"]
iex(14)> page_io = [header, body_io, footer]
["<html><body>", ["hello ", "Bob", "!"], "</body></html>"]
iex(16)> IO.puts page_io
<html><body>hello Bob!</body></html>
:ok
```
TODO:
page = [title, body]
html = [header, page, footer]

Здесь нет копирования, а результат представляет собой дерево из ссылок на разные области памяти.

Применяется везде, где есть IO: запись в файл, запись в сокет.

TODO: например.
запись в файл -- записать IO list, открыть файл, посмотреть


## Keyword List

Легаси со времен, когда BEAM не поддерживала map.

Список кортежей из двух элементов, где первых элемент -- atom() -- ключ, а второй элемент -- значение.

Активно используются до сих пор, хотя вроде бы незачем.

TODO примеры

[{:a, 42}, {:b, 50}]
[a: 42, b: 50]

в отличие от map сохраняют порядок ключей
и могут иметь несколько значений под одним ключом

Сложившаяся традиция:
options -- настройки
Много функций в стандартной библиотеке принимают список options в виде keyword list.

TODO: пример.
String.split мы использовали

TODO: ещё пример
Например функция `IO.inspect/2`, которую можно использовать для отладочной печати.
Суть её работы в том, чтобы принять значение и распечатать в консоль.
Функция позволяет управлять своим поведением через "опции" которые передаются
через последний аргумент, являющийся keyword list`ом:

```elixir-iex
iex(1)> h IO.inspect
# => @spec inspect(item, keyword()) :: ...
iex(2)> IO.inspect([100, 200, 300])
[100, 200, 300]
iex(3)> IO.inspect([100, 200, 300], [width: 3])
[100,
 200,
 300]
```
Такой подход стал настолько широко использоваться что специально для удобства
ввели синтаксический сахар в виде сокращенного синтаксиса, позволяя явно не
указывать скобки для keyword list-а:
```elixir-iex
iex(4)> IO.inspect([100, 200, 300], width: 3, limit: 1)
[100,
 ...]
```
Визуально кажется, что здесь используется varargs(передача переменного количества
аргументов) Но на самом деле Эликсир не поддерживает такой вид передачи и на
деле просто ключи оборачиваются в keyword-список.
Т.е. такой вид полностью аналогичен этому:
```elixir-iex
iex(5)> IO.inspect([100, 200, 300], [width: 3, limit: 1])
[100,
 ...]


Конфигурационные файлы тоже по сложившейся традиции.
TODO: пример коннекта к БД


## Range

TODO

1..10 |> Enum.to_list()
a in range
iterate over range

Build on top of map.

## Sigil

TODO
Список слов
Регулярное выражение
Date, Time
Naive & UTC DateTime

d = ~U[]
d.year
d.month
Map.from_struct(d)

i d
