# Сложные типы (Complex types)

## IO List

Рекурсивный тип данных, который состоит из:
- byte (число в диапазоне 0-255)
- [byte] (список таких чисел)
- String.t (бинарная строка)
- IO List (включает сам себя)

TODO: пример

```
> ... |> flatten()
"Hello world!"
```

Такой тип поддерживается во всех операциях ввода-вывода и позволяет избежать дорогостоящей конкатенации строк.

Не эффективно:

```elixir-iex
iex(8)> header = "<html><body>"
"<html><body>"
iex(9)> footer = "</body></html>"
"</body></html>"
iex(10)> name = "Bob"
"Bob"
iex(11)> body = "hello " <> name <> "!"
"hello Bob!"
iex(12)> page = header <> body <> footer
iex(15)> IO.puts page
<html><body>hello Bob!</body></html>
```
TODO:
page = title <> body
html = header <> page <> footer

Здесь много операций по копированию строк из одной области памяти в другую, чтобы в итоге результат разместился в одной непрерывной области памяти.

Эффективно:

```elixir-iex
iex(8)> header = "<html><body>"
"<html><body>"
iex(9)> footer = "</body></html>"
"</body></html>"
iex(10)> name = "Bob"
"Bob"
iex(13)> body_io = ["hello ", name, "!"]
["hello ", "Bob", "!"]
iex(14)> page_io = [header, body_io, footer]
["<html><body>", ["hello ", "Bob", "!"], "</body></html>"]
iex(16)> IO.puts page_io
<html><body>hello Bob!</body></html>
:ok
```
TODO:
page = [title, body]
html = [header, page, footer]

Здесь нет копирования, а результат представляет собой дерево из ссылок на разные области памяти.

Применяется везде, где есть IO: запись в файл, запись в сокет.

TODO: например.
запись в файл -- записать IO list, открыть файл, посмотреть


## Keyword List

Легаси со времен, когда BEAM не поддерживала map.

Список кортежей из двух элементов, где первых элемент -- atom() -- ключ, а второй элемент -- значение.

Активно используются до сих пор, хотя вроде бы незачем.

TODO примеры

[{:a, 42}, {:b, 50}]
[a: 42, b: 50]

в отличие от map сохраняют порядок ключей
и могут иметь несколько значений под одним ключом

Сложившаяся традиция:
options -- настройки
Много функций в стандартной библиотеке принимают список options в виде keyword list.

TODO: пример.
String.split мы использовали

TODO: ещё пример
Например функция `IO.inspect/2`, которую можно использовать для отладочной печати.
Суть её работы в том, чтобы принять значение и распечатать в консоль.
Функция позволяет управлять своим поведением через "опции" которые передаются
через последний аргумент, являющийся keyword list`ом:

```elixir-iex
iex(1)> h IO.inspect
# => @spec inspect(item, keyword()) :: ...
iex(2)> IO.inspect([100, 200, 300])
[100, 200, 300]
iex(3)> IO.inspect([100, 200, 300], [width: 3])
[100,
 200,
 300]
```
Такой подход стал настолько широко использоваться что специально для удобства
ввели синтаксический сахар в виде сокращенного синтаксиса, позволяя явно не
указывать скобки для keyword list-а:
```elixir-iex
iex(4)> IO.inspect([100, 200, 300], width: 3, limit: 1)
[100,
 ...]
```
Визуально кажется, что здесь используется varargs(передача переменного количества
аргументов) Но на самом деле Эликсир не поддерживает такой вид передачи и на
деле просто ключи оборачиваются в keyword-список.
Т.е. такой вид полностью аналогичен этому:
```elixir-iex
iex(5)> IO.inspect([100, 200, 300], [width: 3, limit: 1])
[100,
 ...]
```

Конфигурационные файлы тоже по сложившейся традиции.
TODO: пример коннекта к БД


## Range

Range - это абстракция позволяющая представляять диапазоны чисел.
```elixir
iex> range = 1..2         # синтаксис обьявления диапазона
iex> 2 in range           # => true
iex> -1 in range          # => false
```

`in` - оператор проверки находится ли заданное число в диапазоне.

Range реализует протокол Enumerable, а значит все функции из модуля Enum могут
с ним работать.

(Note: В Эликсир Протокол нечто похожее на интерфейс в Java(и др. ООП языках).
Упрощенно протокол можно воспринимать как своего рода обещание некой "сущности"
уметь выполнять некое действие принимая на вход заранее обговоренные данные.
Подробнее по протоколам будет в 7 уроке)

Пример функция `Enum.each/2` - позволяет вызвать для каждого
элемента коллекции(перчисления) переданную через аргумент анонимную функцию(лямбду)

```elixir
iex> Enum.each(1..3, fn val -> IO.puts(val) end)      # или кратко &IO.puts/1
1
2
3
```

Под копотом Range - это не отдельный тип данных, а надстройка над Map(Словарём),
содержащий в себе только заданные границы, а не все входящие в эти границы значения.
Поэтому Range экономен к памяти и занимает мало места, причем не зависимо от того
насколько большой диапазон он описывает из 10 цифр или из несколько миллионов.
На деле диапазон(Range) в памяти занимает столько же место сколько небольшой
словарь(Map). Почему это так увидем чуть ниже.

Диапазоны(Ranges) могут быть как восходящими(ascenging) так и
нисходящими(descending). Зависит от заданного шага который по умолчанию = 1
Причем указанные граничные значения всегда входят в сам диапазон.

```elixir
iex> 1..8        # диапазон от 1 до 8 включая 1 и 8
iex> ?A..?H      # диапазон от 65 до 72 (коды ASCII символов от A до H)
```

Строим список целых чисел из диапазона
```elixir
iex> Enum.to_list(1..8)
[1,2,3,4,5,6,7,8]

# немного магии и числа превращаются в буквы-строки (Вспоминаем BitString)
iex> Enum.map(?A..?H, fn codepoint -> <<codepoint>> end)    # или &(<<&1>>)
["A", "B", "C", "D", "E", "F", "G", "H"]
```

Если интересно, то можно запросить подробный отчёт о том, что из себя
представляет конкретное значени. Здесь например мы спрашиваем о значении Range:
```elixir
iex> i 1..4
Term
  1..4
Data type
  Range
Description
  This is a struct representing a range of numbers. It is commonly
  defined using the `first..last//step` syntax. The step is not
  required and defaults to 1.
Raw representation
  %Range{first: 1, last: 4, step: 1}                     # <<< !
Reference modules
  Range
Implemented protocols
  Enumerable, IEx.Info, Inspect
```
О структурах(Struct) будет чуть позже, но здесь можно заметить что сырое
представление диапазона(Range) очень похоже на словарь(Map) которую мы уже
изучили. И как видим содержит он в себе 3 ключа: начало, конец и шаг:
`%Range{first: 1, last: 4, step: 1}`


Немного выйдем за рамки привычного и проявим больше любопытства.
"А Что такое `i` в iex-консоли?"
(Привыкаем самостоятельно находить ответы на вопросы и работать со встроенной
документацией)
```
iex>h i
                              def i(term \\ v(-1))

Prints information about the data type of any given term.

If no argument is given, the value of the previous expression is used.

## Examples

    iex> i(1..5)

Will print:

    Term
      1..5
    Data type
      Range
    Description
      This is a struct. Structs are maps with a __struct__ key.
    Reference modules
      Range, Map

```

1..10 |> Enum.to_list()
a in range
iterate over range

Build on top of map.

## Sigil

TODO
Список слов
Регулярное выражение
Date, Time
Naive & UTC DateTime

d = ~U[]
d.year
d.month
Map.from_struct(d)

i d
