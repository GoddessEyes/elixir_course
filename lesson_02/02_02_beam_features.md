# Важные свойства BEAM

Эликсир и Эрланг объединяет виртуальная машина Erlang Virtual Machine, которую обычно называют BEAM (Bogdan's Erlang Abstract Machine). Оба языка компилируются в один байткод, который исполняет эта машина.

Название не совсем верное, так как машина состоит из интерпретатора байткода (собственно BEAM) и Erlang Runtime System (ERTS).

ERTS представляет собой операционную систему в миниатюре, она реализует:
- планировщик процессов,
- управление памятью,
- ввод-вывод,
- сетевой стек,
- и много других фич.

Она даже может запускаться на железе без родительской ОС.

![BEAM + ERTS](../lesson_12/img/release.png)

Несмотря на эти нюансы, BEAM используется как название для всей виртуальной машины.

Во всех книгах и документации по Erlang/BEAM указаны 4 базовых свойства машины:
- Многопоточность (Concurrency);
- Устойчивость к ошибкам (Fault Tolerance);
- Поддержка распределенных систем (Distribution);
- Горячее обновление кода (Hot Code Upgrade).

К базовым свойствам можно добавить еще несколько:
- Симметричная многопроцессорность (Symmetric Multiprocessing);
- Модель акторов (Actor Model);
- Система реального времени (Soft Real Time);
- Сборщик мусора (Garbage Collector);
- Интерактивная консоль (Erlang/Elixir Shell);
- Трассировка (Tracing).

Многие из этих свойств так или иначе реализованы в виртуальных машин других языков: Java, .NET, JavaScript. Но совокупность этих свойств и особенности реализации делает BEAM уникальной и дает Эликсир и Эрланг разработчикам определенные преимущества.


## Многопоточность (Concurrency)

_Что такое многопоточность, какие бывают виды многопоточности, и какие из них реализованы в BEAM мы будем рассматривать позже. А сейчас быстрый обзор._

BEAM реализует свои потоки (thread) и планировщики (scheduler), независимые от ОС. Эти потоки легковесны, их можно создавать десятки и сотни тысяч. Запуск потоков и переключение между ними происходит очень быстро.

Каждый поток имеет свою изолированную память. Разделяемой памяти между потоками нет (с некоторыми оговорками).

Ошибки в потоках также изолированы, блокировка или падение одного потока не влияет на работу остальных.

Данные между потоками передаются путем "отправки сообщений" (message passing). При этом данные копируются из памяти одного потока в память другого.

Немного цифр:

BEAM способна запускать до **134,217,727 (2^27)** потоков. По умолчанию установлено ограничение в **262,144 (2^18)** потоков. Этого обычно хватает, но если нужно больше, то ограничение можно увеличить в настройках BEAM.

Запуск нового потока занимает **3-5** микросекунд. На старте поток резервирует **2696** байт памяти, включая стек, кучу и метаданные.

BEAM запускает несколько планировщиков, соответственно количеству процессорных ядер. Каждый планировщик использует один процесс ОС, и поверх него запускает эрланговские потоки.

Планировщики умеют балансировать нагрузку, перераспределяя потоки между собой. У них нет задачи постоянно держать равномерную нагрузку на все ядра процессоров, но есть задача избежать больших перекосов, когда одно ядро загружено на 100%, а другое вообще простаивает.

TODO: концепция ограниченого и неограниченого ресурса, потоки как неограниченый ресурс. Отдельный поток (и даже несколько потоков) на каждого клиента.


## Устойчивость к ошибкам (Fault Tolerance)

В большинстве языков обработка ошибок реализуется через механизм исключений. Разработчик может получить относительно безопасный код, если сможет предвидеть все возможные ошибки, правильно расставит try…catch и правильно обработает исключения.

BEAM тоже поддерживает исключения, но это не основной способ обработки ошибок. Если вы возьмете исходники какого-нибудь крупного известного эрланг проекта, например, Cowboy или Riak, и поищите там try..catch, то найдете их очень мало.

Основной способ -- это механизм мониторинга одних потоков другими. BEAM имеет специальные потоки, которые сами не выполняют полезной работы, а наблюдают за другими. Они называются **supervisor** (наблюдатели). А потоки, которые выполняют реальную работу, называются **worker** (рабочие).

Если в рабочем потоке возникает ошибка, он аварийно завершается. Супервизор получает об этом сообщение, и может принять какие-то меры. Стандартная мера -- логировать ошибку и перезапустить рабочий поток заново. При этом мы имеем потери -- текущее состояние памяти потока, но можем продолжать работу.

Супервизоры наблюдают не только за рабочими потоками, но и друг за другом. Для этого все потоки организованы в дерево, где узлами являются супервизоры, а листьями – рабочие потоки.  В более сложной ситуации можно перегрузить всю ветвь дерева, выше и выше по уровню. И, наконец, все дерево целиком.

Есть еще один уровень устойчивости к ошибкам -- объединение узлов в кластер. Если узел все-таки падает, или вообще сервер выходит из строя из-за проблем с железом, то его функцию может взять на себя резервный узел.


## Поддержка распределенных систем (Distribution)

Распределенные системы -- одна из самых сложных областей в программировании. BEAM, Эликсир и Эрланг предлагают некоторые важные средства для разработки таких систем.

Распределенность является необходимым условием для устойчивости к аппаратным авариям, что является одним из требований к BEAM. Железо выходит из строя не так часто, но это случается. Если инфраструктура состоит из сотен серверов, то это случается регулярно, и является штатной ситуацией.

Кроме этого, распределенность обеспечивает горизонтальное масштабирование, и позволяет строить большие системы, справляющиеся с большими нагрузками и большими данными.

Одно из важных свойств кластера, состоящего из узлов BEAM, это **сетевая прозрачность** (location transparency). Потоки передают сообщения друг другу не зависимо от того, находятся ли они на одном узле, или на разных.

BEAM обеспечивает транспорт прозрачно для программиста: открывает сокеты, устанавливает TCP соединения между узлами и мониторит их состояние. О всех этих низкоуровневых вещах программисту думать не нужно.

BEAM-узлы, собранные в кластер, формируют доверенную среду (trusted environment). Любой поток может посылать любые сообщения кому угодно. И любой код выполняется с равными правами, без ограничений. Это удобно, но не безопасно. Подразумевается, что все узлы находятся в одной локальной сети, и сеть защищена от внешнего мира.


## Горячее обновление кода (Hot Code Upgrade)

Пресловутое горячее обновление кода, о котором, наверняка, слышали все :) В свое время (80-90-е годы) это была важно для телекомуникационного оборудования, где нужно было обновлять софт не прерывая обслуживания клиентов, и не разрывая текущие телефонные сессии.

В современном мире это не так важно. Если мы научились поддерживать непрерывную работу кластера в условиях, когда часть узлов выходят из строя, то мы можем применять этот же механизм для обновления -- выводить узлы из кластера по-очереди, обновлять их, и возвращать обратно в кластер.

Горячее обновление работает просто на уровне отдельных модулей, но вовсе не просто на уровне всей системы в целом. Там могут меняться не только версии кода, но и структура данных в памяти потоков, и характер взаимодействия между компонентами системы.

Между тем, горячее обновление остается полезным как инструмент разработки. Программист может вносить изменения в код не перегружая систему, что довольно удобно. И мы тоже будем часто пользоваться этим в рамках нашего учебного курса.


## Симметричная многопроцессорность (Symmetric Multiprocessing)

С 2006 года BEAM умеет эффективно использовать все процессорные ядра в системе, и перераспределять нагрузку между ними.

То есть, поток, запущенный под одним планировщиком, на одном процессорном ядре, может быть передан под управление другому планировщику, и продолжить выполнение на другом процессором ядре. Это позволяет избежать ситуаций, когда одно ядро загружено на 100%, а другое простаивает.

Причем, это справедливо для систем с большим количеством ядер. Например, BEAM запускали на чипах с 1024 ядрами, и она эффективно использовала ресурс всех этих ядер.

Разработчикам на других языках программирования нужно приложить немало усилий, чтобы добиться такого эффекта. Разработчики Эликсир и Эрланг получают это свойство бесплатно, "из коробки".


## Модель акторов (Actor Model)

Модель акторов является одним из способов реализации многопоточности.

Система состоит из **акторов**, которые действуют паралельно и независимо друг от друга, имеют собственное состояние и общаются друг с другом с помощью отправки сообщений (message passing).

Отправка сообщений является асинхронной. При необходимости можно реализовать синхронный вызов -- блокировать поток на какое-то время, и ждать, пока придет ответное сообщение.

Каждый актор имеет mailbox, где накапливаются полученные им сообщения. Это специальная область памяти потока. Поток проверяет свой mailbox, когда считает нужным, и реагирует на сообщения, как считает нужным.

Для некоторых языков модель акторов реализована как библиотека. Например, библиотека [Akka](http://akka.io/) для Java и Scala. В Эликсир и Эрланг эта модель реализована в виртуальной машине и поддерживается непосредственно на уровне языка.

Преимущества и недостатки этой модели в сравнении с другими реализациями многопоточности мы будем рассматривать позже.


## Система реального времени (Soft Real Time)

Система реального времени -- система, которая должна реагировать на запросы в рамках заданного лимита времени. Нарушение лимита времени может считаться отказом системы (hard real-time) или снижением качества работы системы (soft real-time).

Такие системы применяются в промышленности, в транспорте, в медицине. Например, управление атомной электростанцией или авионика самолета.

Это еще одна сложная область программирования, где можно применять Эликсир и Эрланг.

BEAM может поддерживать soft real-time систему благодаря:
- вытесняющей многозадачности (preemptive scheduling);
- изолированному IO;
- особенностям сборки мусора (garbage collection).

Планировщики BEAM реализуют вытесняющую многозадачность. Это значит, они принудительно передают управление от одного потока другому, а не ждут, пока поток сам согласится передать управление.

IO не выполняется в каждом потоке отдельно, а через специализированный пул потоков. Поэтому блокировки в IO мало влияют на всю систему в целом.

Про сборку мусора поговорим отдельно.


## Сборщик мусора (Garbage Collector)

Сборка мусора в функциональных языках несколько проще, чем в императивных, благодаря неизменяемым данным.  Сборщику точно известно, что переменные, созданные раньше, не могут указывать на объекты, созданные позже.

Сборщик мусора в BEAM делит объекты на два поколения: молодые и старые. И исходит из предположения, что большинство молодых объектов являются короткоживущими, и для них память нужно чистить чаще. А большинство старых объектов являются долгоживущими, и для них память можно чистить реже
.
В этом нет ничего особенного, во многих других языках сборка мусора работает аналогично.

Особенность BEAM, это отдельный сборщик мусора для каждого потока. Все сборщики работают независимо друг от друга, в разные моменты времени, и останавливают только свой поток. Отсюда отсутствие эффекта stop world, характерного, например, для JVM, когда сборщик мусора должен остановить всю систему, чтобы выполнить свою работу.

Если поток короткоживущий (что довольно обычно для BEAM), то после его завершения вся память потока целиком освобождается, а сборщик мусора даже не успевает поработать.

Если поток долгоживущий, но потребляет мало памяти (типично для супервизора и других потоков, выполняющих "менеджерские" задачи), то в нем сборщик мусора запускается очень редко, или никогда.

В результате сборка мусора оказывает мало влияния на производительность системы.


## Интерактивная консоль (Erlang/Elixir Shell)

Как и многие другие языки, Эликсир имеет REPL консоль. Ей удобно пользоваться при разработке.

Но ей можно пользоваться и на продакшен системе. Можно подключиться к работающему узлу, вызывать любую функцию любого модуля, отправить сообщение любому потоку, прочитать и изменить состояние любого потока. То есть, взаимодействовать с системой в реальном времени.

Это очень помогает в диагностике разных проблем и исправлении их на лету.


## Трассировка (Tracing)

В BEAM есть встроенный механизм трассировки. При должной осторожности он мало влияет на общую производительность системы. Поэтому его можно использовать на живой, продакшен системе.

Этот механизм позволяет получать в реальном времени информацию:
- вызовы функций, аргументы, возвращаемые значения;
- жизненный цикл потоков (старт, остановка, связи с другими потоками);
- отправка и получение сообщений;
- состояние памяти потоков;
- информацию о работе планировщика;
- информацию о потреблении памяти и работе сборщиков мусора.

Теоретически можно узнать почти все о работе системы. Практически информации очень много, и сложность в том, чтобы найти именно ту, которая нужна.

Данные трассировки можно наблюдать в консоли, или перенаправить в файл. Их можно получать на том же узле, или перенаправить на другой узел, чтобы обрабатывать и анализировать там.
