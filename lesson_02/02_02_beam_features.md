# Свойства BEAM

Эликсир и Эрланг объединяет виртуальная машина **Erlang Virtual Machine**, которую обычно называют BEAM (Bogdan's Erlang Abstract Machine). Оба языка компилируются в один байткод, который исполняет эта машина.

Название не совсем верное, так как машина состоит из интерпретатора байткода (собственно BEAM) и Erlang Runtime System (ERTS).

ERTS представляет собой операционную систему в миниатюре, она реализует:
- планировщик процессов,
- управление памятью,
- ввод-вывод,
- сетевой стек,
- и много других фич.

Она даже может запускаться на железе без родительской ОС.

![BEAM + ERTS](../lesson_13/img/release.png)

Несмотря на эти нюансы, BEAM часто используется как название для всей виртуальной машины.

Во книгах по Эрланг часто указывают на 4 базовых свойства машины:
- Многопоточность (Concurrency);
- Устойчивость к ошибкам (Fault Tolerance);
- Поддержка распределенных систем (Distribution);
- Горячее обновление кода (Hot Code Upgrade).

К этому можно добавить еще несколько свойств:
- Симметричная многопроцессорность (Symmetric Multiprocessing);
- Модель акторов (Actor Model);
- Система реального времени (Soft Real Time);
- Сборщик мусора (Garbage Collector);
- Интерактивная консоль (Erlang/Elixir Shell);
- Трассировка (Tracing).

Многое из этого так или иначе реализовано в виртуальных машин других языков: Java, .NET, JavaScript. Но совокупность этих свойств и особенности реализации делают BEAM уникальной и дает Эликсир и Эрланг разработчикам определенные преимущества.


## Многопоточность (Concurrency)

BEAM реализует свои процессы (thread) и планировщики (scheduler), независимые от ОС. Эти процессы легковесны, их можно создавать десятки и сотни тысяч. Запуск процессов и переключение между ними происходит очень быстро.

Каждый процесс имеет свою изолированную память. Разделяемой памяти (shared memory) нет (с некоторыми оговорками).

Ошибки в процессах также изолированы, блокировка или падение одного процесса не влияет на работу остальных.

Данные между процессами передаются путем отправки сообщений (message passing). При этом данные копируются из памяти одного процесса в память другого.

Немного цифр:

BEAM способна запускать до **134,217,727 (2^27)** процессов. По умолчанию установлено ограничение в **262,144 (2^18)** процессов. Этого обычно хватает, но если нужно больше, то ограничение можно увеличить в настройках BEAM.

Запуск нового процесса занимает **3-5** микросекунд. На старте процесс резервирует **2696** байт памяти, включая стек, кучу и метаданные.

BEAM запускает несколько планировщиков, соответственно количеству процессорных ядер. Каждый планировщик использует один процесс ОС, и поверх него запускает свои процессы.

Планировщики умеют балансировать нагрузку, перераспределяя процессы между собой. У них нет задачи постоянно держать равномерную нагрузку на все ядра процессоров, но есть задача избежать больших перекосов, когда одно ядро загружено на 100%, а другое вообще простаивает.


## Устойчивость к ошибкам (Fault Tolerance)

В большинстве языков обработка ошибок реализуется через механизм исключений. Разработчик может получить относительно безопасный код, если сможет предвидеть все возможные ошибки, правильно расставит `try…catch` и правильно обработает исключения.

BEAM тоже поддерживает исключения, но это не основной способ обработки ошибок. Если вы возьмете исходники какого-нибудь крупного известного эрланг проекта, например, Cowboy или Riak, и поищите там `try..catch`, то найдете их очень мало.

Основной способ -- это механизм мониторинга одних процессов другими. BEAM имеет специальные процессы, которые сами не выполняют полезной работы, а наблюдают за другими. Они называются **supervisor** (наблюдатели). А процессы, которые выполняют реальную работу, называются **worker** (рабочие).

Если в рабочем процессе возникает ошибка, он аварийно завершается. Супервизор получает об этом сообщение и может принять какие-то меры. Стандартная мера -- логировать ошибку и перезапустить рабочий процесс заново. При этом мы имеем потери -- текущее состояние памяти процесса, но можем продолжать работу.

Супервизоры наблюдают не только за рабочими процессами, но и друг за другом. Для этого все они организованы в дерево, где узлами являются супервизоры, а листьями – рабочие процессы.  В более сложной ситуации можно перегрузить всю ветвь дерева, выше и выше по уровню. И, наконец, все дерево целиком.

Есть еще один уровень устойчивости к ошибкам -- объединение узлов в кластер. Если узел падает, или вообще сервер выходит из строя из-за проблем с железом, то его функцию может взять на себя резервный узел.


## Поддержка распределенных систем (Distribution)

Распределенные системы -- одна из самых сложных областей в программировании. BEAM, Эликсир и Эрланг предлагают некоторые важные средства для разработки таких систем.

Распределенность является необходимым условием для устойчивости к аппаратным авариям. Железо выходит из строя не так часто, но это случается. Если инфраструктура состоит из сотен серверов, то это случается регулярно и является штатной ситуацией.

Кроме этого, распределенность обеспечивает горизонтальное масштабирование и позволяет строить большие системы, справляющиеся с большими нагрузками и большими данными.

Одно из важных свойств кластера, состоящего из узлов BEAM, это сетевая прозрачность (location transparency). Процессы передают сообщения друг другу не зависимо от того, находятся ли они на одном узле, или на разных.

BEAM обеспечивает транспорт прозрачно для программиста: открывает сокеты, устанавливает TCP соединения между узлами и мониторит их состояние. О всех этих низкоуровневых вещах программисту думать не нужно.

BEAM-узлы, собранные в кластер, формируют доверенную среду (trusted environment). Любой процесс может посылать любые сообщения кому угодно. И любой код выполняется с равными правами, без ограничений. Это удобно, но не безопасно. Подразумевается, что все узлы находятся в одной локальной сети, и сеть защищена от внешнего мира.


## Горячее обновление кода (Hot Code Upgrade)

В свое время (80-90-е годы) горячее обновление кода было важным для телекомуникационного оборудования, где нужно было выполнять обновления не прерывая обслуживания клиентов и не разрывая текущие телефонные сессии.

В современном мире это уже не так важно. Если мы научились поддерживать непрерывную работу кластера в условиях, когда часть узлов выходят из строя, то мы можем применять этот же механизм для обновления -- выводить узлы из кластера по-очереди, обновлять их, и возвращать обратно в кластер.

Горячее обновление работает просто на уровне отдельных модулей, но вовсе не просто на уровне всей системы в целом. Там могут меняться не только версии кода, но и структура данных в памяти процессов, и характер взаимодействия между компонентами системы.

Между тем, горячее обновление остается полезным как инструмент разработки. Программист может вносить изменения в код не перегружая систему, работающую локально на его машине, что довольно удобно. И мы тоже будем пользоваться этим в рамках нашего учебного курса.


## Симметричная многопроцессорность (Symmetric Multiprocessing)

BEAM умеет эффективно использовать все процессорные ядра в системе и перераспределять нагрузку между ними.

То есть, процесс, запущенный под одним планировщиком, на одном процессорном ядре, может быть передан под управление другому планировщику, и продолжить выполнение на другом процессором ядре. Это позволяет избежать ситуаций, когда одно ядро загружено на 100%, а другое простаивает.

Причем, это справедливо для систем с большим количеством ядер. Например, BEAM запускали на чипах с 1024 ядрами, и она эффективно использовала ресурс всех этих ядер.

Разработчикам на других языках программирования нужно приложить немало усилий, чтобы добиться такого эффекта. Разработчики Эликсир и Эрланг получают это свойство бесплатно, "из коробки".


## Модель акторов (Actor Model)

Модель акторов является одним из способов реализации многопоточности.

Система состоит из акторов, которые действуют паралельно и независимо друг от друга, имеют собственное состояние и общаются друг с другом с помощью отправки сообщений (message passing).

Отправка сообщений является асинхронной. При необходимости можно реализовать синхронный вызов -- блокировать процесс на какое-то время, и ждать, пока придет ответное сообщение.

Каждый актор имеет почтовый ящик (mailbox), где накапливаются полученные им сообщения. Это специальная область памяти процесса. Актор проверяет свой почтовый ящик, когда считает нужным, и реагирует на сообщения, как считает нужным.

Для некоторых языков модель акторов реализована как библиотека. Например, библиотека [Akka](http://akka.io/) для Java и Scala. В Эликсир и Эрланг эта модель реализована в виртуальной машине и поддерживается непосредственно на уровне языка.


## Система реального времени (Soft Real Time)

Система реального времени -- система, которая должна реагировать на запросы в рамках заданного лимита времени. Нарушение лимита времени может считаться отказом системы (hard real-time) или снижением качества работы системы (soft real-time).

Такие системы применяются в промышленности, в транспорте, в медицине. Это может быть, например, управление атомной электростанцией или авионика самолета.

Это еще одна сложная область программирования, где можно применять Эликсир и Эрланг.

BEAM может поддерживать soft real-time систему благодаря:
- вытесняющей многозадачности (preemptive scheduling);
- изолированному IO;
- особенностям сборки мусора (garbage collection).

Планировщики BEAM реализуют вытесняющую многозадачность. Это значит, они принудительно передают управление от одного процесса другому, а не ждут, пока процесс сам согласится передать управление.

IO выполняется не в каждом процессе отдельно, а через специализированный пул процессов. Поэтому блокировки в IO мало влияют на всю систему в целом.

Про сборку мусора поговорим отдельно.


## Сборщик мусора (Garbage Collector)

Сборка мусора в функциональных языках несколько проще, чем в императивных, благодаря неизменяемым данным.  Сборщику точно известно, что переменные, созданные раньше, не могут указывать на объекты, созданные позже.

Сборщик мусора в BEAM делит объекты на два поколения: молодые и старые. И исходит из предположения, что большинство молодых объектов являются короткоживущими, и для них память нужно чистить чаще. А большинство старых объектов являются долгоживущими, и для них память можно чистить реже
.
В этом нет ничего особенного, во многих других языках сборка мусора работает аналогично.

Особенность BEAM в том, что каждый процесс имеет отдельный сборщик мусора. Все они работают независимо друг от друга, запускаются в разные моменты времени, и останавливают только свой процесс. Отсюда отсутствие эффекта **stop world**, характерного, например, для JVM, когда сборщик мусора должен остановить всю систему целиком чтобы выполнить свою работу.

Если процесс короткоживущий, то после его завершения вся его память освобождается целиком, а сборщик мусора даже не успевает поработать.

Если процесс долгоживущий, но потребляет мало памяти (типично для супервизора и других процессов, выполняющих "менеджерские" задачи), то в нем сборщик мусора запускается очень редко, или никогда.

В результате сборка мусора оказывает мало влияния на производительность системы.


## Интерактивная консоль (Erlang/Elixir Shell)

Как и многие другие языки, Эликсир имеет REPL консоль. Ей удобно пользоваться при разработке.

Но ей можно пользоваться и на production системе. Можно подключиться к работающему узлу, вызывать любую функцию любого модуля, отправить сообщение любому процессу, прочитать и изменить состояние любого процесса. То есть, взаимодействовать с системой в реальном времени.

Это очень помогает в диагностике разных проблем и исправлении их на лету.


## Трассировка (Tracing)

В BEAM есть встроенный механизм трассировки. При должной осторожности он мало влияет на общую производительность системы. Поэтому его можно использовать на живой, production системе.

Этот механизм позволяет получать в реальном времени информацию:
- вызовы функций, аргументы, возвращаемые значения;
- жизненный цикл процессов (старт, остановка, связи с другими процессами);
- отправка и получение сообщений;
- состояние памяти процессов;
- информацию о работе планировщика;
- информацию о потреблении памяти и работе сборщиков мусора.

Теоретически можно узнать почти все о работе системы. Практически информации очень много, и сложность в том, чтобы найти именно ту, которая нужна.

Данные трассировки можно наблюдать в консоли, или перенаправить в файл. Их можно получать на том же узле, или перенаправить на другой узел, чтобы обрабатывать и анализировать там.
